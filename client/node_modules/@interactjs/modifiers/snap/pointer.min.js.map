{
	"version": 3,
	"sources": [
		"pointer.ts"
	],
	"names": [
		"utils",
		"makeModifier",
		"snap",
		"start",
		"arg",
		"interaction",
		"interactable",
		"element",
		"rect",
		"state",
		"startOffset",
		"options",
		"origin",
		"offsetWithOrigin",
		"rectToXY",
		"resolveRectLike",
		"getOriginXY",
		"prepared",
		"name",
		"getOrigin",
		"x",
		"y",
		"snapOffset",
		"offset",
		"coords",
		"page",
		"offsetRect",
		"relativePoints",
		"offsets",
		"length",
		"map",
		"relativePoint",
		"index",
		"left",
		"width",
		"top",
		"height",
		"extend",
		"set",
		"targets",
		"relativeX",
		"relativeY",
		"len",
		"snapTarget",
		"target",
		"is",
		"func",
		"push",
		"number",
		"range",
		"source",
		"closest",
		"inRange",
		"distance",
		"delta",
		"dx",
		"dy",
		"hypot",
		"Infinity",
		"defaults",
		"endOnly",
		"enabled"
	],
	"mappings": "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",
	"sourcesContent": [
		"import * as utils from '@interactjs/utils/index'\nimport { makeModifier, ModifierArg, ModifierState } from '../base'\n\nexport interface Offset {\n  x: number\n  y: number\n  index: number\n  relativePoint?: Interact.Point\n}\n\nexport interface SnapPosition {\n  x?: number\n  y?: number\n  range?: number\n  offset?: Offset\n  [index: string]: any\n}\n\nexport type SnapFunction = (\n  x: number,\n  y: number,\n  interaction: Interact.Interaction,\n  offset: Offset,\n  index: number\n) => SnapPosition\nexport type SnapTarget = SnapPosition | SnapFunction\nexport interface SnapOptions {\n  targets: SnapTarget[]\n  // target range\n  range: number\n  // self points for snapping. [0,0] = top left, [1,1] = bottom right\n  relativePoints: Interact.Point[]\n  // startCoords = offset snapping from drag start page position\n  offset: Interact.Point | Interact.RectResolvable<[Interact.Interaction]> | 'startCoords'\n  offsetWithOrigin?: boolean\n  origin: Interact.RectResolvable<[Interact.Element]> | Interact.Point\n  endOnly?: boolean\n  enabled?: boolean\n}\n\nexport type SnapState = ModifierState<SnapOptions, {\n  offsets?: Offset[]\n  closest?: any\n  targetFields?: string[][]\n}>\n\nfunction start (arg: ModifierArg<SnapState>) {\n  const { interaction, interactable, element, rect, state, startOffset } = arg\n  const { options } = state\n  const origin = options.offsetWithOrigin\n    ? getOrigin(arg)\n    : { x: 0, y: 0 }\n\n  let snapOffset: Interact.Point\n\n  if (options.offset === 'startCoords') {\n    snapOffset = {\n      x: interaction.coords.start.page.x,\n      y: interaction.coords.start.page.y,\n    }\n  }\n  else  {\n    const offsetRect = utils.rect.resolveRectLike(options.offset as any, interactable, element, [interaction])\n\n    snapOffset = utils.rect.rectToXY(offsetRect) || { x: 0, y: 0 }\n    snapOffset.x += origin.x\n    snapOffset.y += origin.y\n  }\n\n  const { relativePoints } = options\n\n  state.offsets = rect && relativePoints && relativePoints.length\n    ?  relativePoints.map((relativePoint, index) => ({\n      index,\n      relativePoint,\n      x: startOffset.left - (rect.width  * relativePoint.x) + snapOffset.x,\n      y: startOffset.top  - (rect.height * relativePoint.y) + snapOffset.y,\n    }))\n    : [utils.extend({\n      index: 0,\n      relativePoint: null,\n    }, snapOffset)]\n}\n\nfunction set (arg: ModifierArg<SnapState>) {\n  const { interaction, coords, state } = arg\n  const { options, offsets } = state\n\n  const origin = utils.getOriginXY(interaction.interactable, interaction.element, interaction.prepared.name)\n  const page = utils.extend({}, coords)\n  const targets = []\n\n  if (!options.offsetWithOrigin) {\n    page.x -= origin.x\n    page.y -= origin.y\n  }\n\n  for (const offset of offsets) {\n    const relativeX = page.x - offset.x\n    const relativeY = page.y - offset.y\n\n    for (let index = 0, len = options.targets.length; index < len; index++) {\n      const snapTarget = options.targets[index]\n      let target\n\n      if (utils.is.func(snapTarget)) {\n        target = snapTarget(relativeX, relativeY, interaction, offset, index)\n      }\n      else {\n        target = snapTarget\n      }\n\n      if (!target) { continue }\n\n      targets.push({\n        x: (utils.is.number(target.x) ? target.x : relativeX) + offset.x,\n        y: (utils.is.number(target.y) ? target.y : relativeY) + offset.y,\n\n        range: utils.is.number(target.range) ? target.range : options.range,\n        source: snapTarget,\n        index,\n        offset,\n      })\n    }\n  }\n\n  const closest = {\n    target: null,\n    inRange: false,\n    distance: 0,\n    range: 0,\n    delta: { x: 0, y: 0 },\n  }\n\n  for (const target of targets) {\n    const range = target.range\n    const dx = target.x - page.x\n    const dy = target.y - page.y\n    const distance = utils.hypot(dx, dy)\n    let inRange = distance <= range\n\n    // Infinite targets count as being out of range\n    // compared to non infinite ones that are in range\n    if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n      inRange = false\n    }\n\n    if (!closest.target || (inRange\n      // is the closest target in range?\n      ? (closest.inRange && range !== Infinity\n        // the pointer is relatively deeper in this target\n        ? distance / range < closest.distance / closest.range\n        // this target has Infinite range and the closest doesn't\n        : (range === Infinity && closest.range !== Infinity) ||\n          // OR this target is closer that the previous closest\n          distance < closest.distance)\n      // The other is not in range and the pointer is closer to this target\n      : (!closest.inRange && distance < closest.distance))) {\n      closest.target = target\n      closest.distance = distance\n      closest.range = range\n      closest.inRange = inRange\n      closest.delta.x = dx\n      closest.delta.y = dy\n    }\n  }\n\n  if (closest.inRange) {\n    coords.x = closest.target.x\n    coords.y = closest.target.y\n  }\n\n  state.closest = closest\n  return closest\n}\n\nfunction getOrigin (arg: Partial<ModifierArg<SnapState>>) {\n  const { element } = arg.interaction\n  const optionsOrigin = utils.rect.rectToXY(\n    utils.rect.resolveRectLike(arg.state.options.origin as any, null, null, [element]),\n  )\n  const origin = optionsOrigin || utils.getOriginXY(\n    arg.interactable,\n    element,\n    arg.interaction.prepared.name,\n  )\n\n  return origin\n}\n\nconst defaults: SnapOptions = {\n  range  : Infinity,\n  targets: null,\n  offset: null,\n  offsetWithOrigin: true,\n  origin: null,\n  relativePoints: null,\n  endOnly: false,\n  enabled: false,\n}\nconst snap = {\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(snap, 'snap')\nexport { snap }\n"
	]
}