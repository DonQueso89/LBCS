{
	"version": 3,
	"sources": [
		"Interactable.ts"
	],
	"names": [
		"arr",
		"browser",
		"clone",
		"getElementRect",
		"matchesUpTo",
		"nodeContains",
		"trySelector",
		"extend",
		"is",
		"normalizeListeners",
		"getWindow",
		"Eventable",
		"isNonNativeEvent",
		"Interactable",
		"_defaults",
		"base",
		"perAction",
		"actions",
		"constructor",
		"target",
		"options",
		"defaultContext",
		"_scopeEvents",
		"this",
		"_actions",
		"events",
		"_context",
		"_win",
		"_doc",
		"context",
		"document",
		"set",
		"setOnEvents",
		"actionName",
		"phases",
		"func",
		"onstart",
		"on",
		"onmove",
		"onend",
		"oninertiastart",
		"updatePerActionListeners",
		"prev",
		"cur",
		"array",
		"object",
		"off",
		"setPerAction",
		"defaults",
		"optionName_",
		"optionName",
		"actionOptions",
		"optionValue",
		"listeners",
		"from",
		"plainObject",
		"enabled",
		"bool",
		"getRect",
		"element",
		"string",
		"querySelector",
		"rectChecker",
		"checker",
		"_backCompatOption",
		"newValue",
		"action",
		"map",
		"origin",
		"deltaSource",
		"inContext",
		"ownerDocument",
		"testIgnoreAllow",
		"targetNode",
		"eventTarget",
		"testIgnore",
		"ignoreFrom",
		"testAllow",
		"allowFrom",
		"fire",
		"iEvent",
		"_onOff",
		"method",
		"typeArg",
		"listenerArg",
		"addRemove",
		"type",
		"wheelEvent",
		"listener",
		"types",
		"actionName_",
		"methodDict",
		"methodName",
		"setting",
		"unset",
		"delegatedEvents",
		"delegated",
		"i",
		"length",
		"selector",
		"splice",
		"l",
		"removeDelegate",
		"remove"
	],
	"mappings": "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",
	"sourcesContent": [
		"import * as arr from '@interactjs/utils/arr'\nimport browser from '@interactjs/utils/browser'\nimport clone from '@interactjs/utils/clone'\nimport { getElementRect, matchesUpTo, nodeContains, trySelector } from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport * as is from '@interactjs/utils/is'\nimport normalizeListeners from '@interactjs/utils/normalizeListeners'\nimport { getWindow } from '@interactjs/utils/window'\nimport Eventable from './Eventable'\nimport { ActionDefaults, Defaults, Options } from './defaultOptions'\nimport { Actions, isNonNativeEvent } from './scope'\n\ntype IgnoreValue = string | Interact.Element | boolean\n\n/** */\nexport class Interactable implements Partial<Eventable> {\n  protected get _defaults (): Defaults {\n    return {\n      base: {},\n      perAction: {},\n      actions: {} as ActionDefaults,\n    }\n  }\n\n  readonly options!: Required<Options>\n  readonly _actions: Actions\n  readonly target: Interact.Target\n  readonly events = new Eventable()\n  readonly _context: Interact.Context\n  readonly _win: Window\n  readonly _doc: Document\n\n  /** */\n  constructor (target: Interact.Target, options: any, defaultContext: Document | Interact.Element, private readonly _scopeEvents: Interact.Scope['events']) {\n    this._actions = options.actions\n    this.target   = target\n    this._context = options.context || defaultContext\n    this._win     = getWindow(trySelector(target) ? this._context : target)\n    this._doc     = this._win.document\n\n    this.set(options)\n  }\n\n  setOnEvents (actionName: Interact.ActionName, phases: NonNullable<any>) {\n    if (is.func(phases.onstart)) { this.on(`${actionName}start`, phases.onstart) }\n    if (is.func(phases.onmove)) { this.on(`${actionName}move`, phases.onmove) }\n    if (is.func(phases.onend)) { this.on(`${actionName}end`, phases.onend) }\n    if (is.func(phases.oninertiastart)) { this.on(`${actionName}inertiastart`, phases.oninertiastart) }\n\n    return this\n  }\n\n  updatePerActionListeners (actionName: Interact.ActionName, prev: Interact.Listeners, cur: Interact.Listeners) {\n    if (is.array(prev) || is.object(prev)) {\n      this.off(actionName, prev)\n    }\n\n    if (is.array(cur) || is.object(cur)) {\n      this.on(actionName, cur)\n    }\n  }\n\n  setPerAction (actionName: Interact.ActionName, options: Interact.OrBoolean<Options>) {\n    const defaults = this._defaults\n\n    // for all the default per-action options\n    for (const optionName_ in options) {\n      const optionName = optionName_ as keyof Interact.PerActionDefaults\n      const actionOptions = this.options[actionName]\n      const optionValue: any = options[optionName]\n\n      // remove old event listeners and add new ones\n      if (optionName === 'listeners') {\n        this.updatePerActionListeners(actionName, actionOptions.listeners, optionValue as Interact.Listeners)\n      }\n\n      // if the option value is an array\n      if (is.array<any>(optionValue)) {\n        (actionOptions[optionName] as any) = arr.from(optionValue)\n      }\n      // if the option value is an object\n      else if (is.plainObject(optionValue)) {\n        // copy the object\n        (actionOptions[optionName] as any) = extend(\n          actionOptions[optionName] || {} as any,\n          clone(optionValue))\n\n        // set anabled field to true if it exists in the defaults\n        if (is.object(defaults.perAction[optionName]) && 'enabled' in (defaults.perAction[optionName] as any)) {\n          (actionOptions[optionName] as any).enabled = optionValue.enabled !== false\n        }\n      }\n      // if the option value is a boolean and the default is an object\n      else if (is.bool(optionValue) && is.object(defaults.perAction[optionName])) {\n        (actionOptions[optionName] as any).enabled = optionValue\n      }\n      // if it's anything else, do a plain assignment\n      else {\n        (actionOptions[optionName] as any) = optionValue\n      }\n    }\n  }\n\n  /**\n   * The default function to get an Interactables bounding rect. Can be\n   * overridden using {@link Interactable.rectChecker}.\n   *\n   * @param {Element} [element] The element to measure.\n   * @return {object} The object's bounding rectangle.\n   */\n  getRect (element: Interact.Element) {\n    element = element || (is.element(this.target)\n      ? this.target\n      : null)\n\n    if (is.string(this.target)) {\n      element = element || this._context.querySelector(this.target)\n    }\n\n    return getElementRect(element)\n  }\n\n  /**\n   * Returns or sets the function used to calculate the interactable's\n   * element's rectangle\n   *\n   * @param {function} [checker] A function which returns this Interactable's\n   * bounding rectangle. See {@link Interactable.getRect}\n   * @return {function | object} The checker function or this Interactable\n   */\n  rectChecker (checker: (element: Interact.Element) => any) {\n    if (is.func(checker)) {\n      this.getRect = checker\n\n      return this\n    }\n\n    if (checker === null) {\n      delete this.getRect\n\n      return this\n    }\n\n    return this.getRect\n  }\n\n  _backCompatOption (optionName: keyof Interact.Options, newValue: any) {\n    if (trySelector(newValue) || is.object(newValue)) {\n      (this.options[optionName] as any) = newValue\n\n      for (const action in this._actions.map) {\n        (this.options[action][optionName] as any) = newValue\n      }\n\n      return this\n    }\n\n    return this.options[optionName]\n  }\n\n  /**\n   * Gets or sets the origin of the Interactable's element.  The x and y\n   * of the origin will be subtracted from action event coordinates.\n   *\n   * @param {Element | object | string} [origin] An HTML or SVG Element whose\n   * rect will be used, an object eg. { x: 0, y: 0 } or string 'parent', 'self'\n   * or any CSS selector\n   *\n   * @return {object} The current origin or this Interactable\n   */\n  origin (newValue: any) {\n    return this._backCompatOption('origin', newValue)\n  }\n\n  /**\n   * Returns or sets the mouse coordinate types used to calculate the\n   * movement of the pointer.\n   *\n   * @param {string} [newValue] Use 'client' if you will be scrolling while\n   * interacting; Use 'page' if you want autoScroll to work\n   * @return {string | object} The current deltaSource or this Interactable\n   */\n  deltaSource (newValue?: string) {\n    if (newValue === 'page' || newValue === 'client') {\n      this.options.deltaSource = newValue\n\n      return this\n    }\n\n    return this.options.deltaSource\n  }\n\n  /**\n   * Gets the selector context Node of the Interactable. The default is\n   * `window.document`.\n   *\n   * @return {Node} The context Node of this Interactable\n   */\n  context () {\n    return this._context\n  }\n\n  inContext (element: Document | Node) {\n    return (this._context === element.ownerDocument ||\n            nodeContains(this._context, element))\n  }\n\n  testIgnoreAllow (\n    this: Interactable,\n    options: { ignoreFrom?: IgnoreValue, allowFrom?: IgnoreValue },\n    targetNode: Node,\n    eventTarget: Interact.EventTarget,\n  ) {\n    return (!this.testIgnore(options.ignoreFrom, targetNode, eventTarget) &&\n            this.testAllow(options.allowFrom, targetNode, eventTarget))\n  }\n\n  testAllow (\n    this: Interactable,\n    allowFrom: IgnoreValue,\n    targetNode: Node,\n    element: Interact.EventTarget,\n  ) {\n    if (!allowFrom) { return true }\n\n    if (!is.element(element)) { return false }\n\n    if (is.string(allowFrom)) {\n      return matchesUpTo(element, allowFrom, targetNode)\n    }\n    else if (is.element(allowFrom)) {\n      return nodeContains(allowFrom, element)\n    }\n\n    return false\n  }\n\n  testIgnore (\n    this: Interactable,\n    ignoreFrom: IgnoreValue,\n    targetNode: Node,\n    element: Interact.EventTarget,\n  ) {\n    if (!ignoreFrom || !is.element(element)) { return false }\n\n    if (is.string(ignoreFrom)) {\n      return matchesUpTo(element, ignoreFrom, targetNode)\n    }\n    else if (is.element(ignoreFrom)) {\n      return nodeContains(ignoreFrom, element)\n    }\n\n    return false\n  }\n\n  /**\n   * Calls listeners for the given InteractEvent type bound globally\n   * and directly to this Interactable\n   *\n   * @param {InteractEvent} iEvent The InteractEvent object to be fired on this\n   * Interactable\n   * @return {Interactable} this Interactable\n   */\n  fire (iEvent: object) {\n    this.events.fire(iEvent)\n\n    return this\n  }\n\n  _onOff (method: 'on' | 'off', typeArg: Interact.EventTypes, listenerArg?: Interact.ListenersArg | null, options?: any) {\n    if (is.object(typeArg) && !is.array(typeArg)) {\n      options = listenerArg\n      listenerArg = null\n    }\n\n    const addRemove = method === 'on' ? 'add' : 'remove'\n    const listeners = normalizeListeners(typeArg, listenerArg)\n\n    for (let type in listeners) {\n      if (type === 'wheel') { type = browser.wheelEvent }\n\n      for (const listener of listeners[type]) {\n        // if it is an action event type\n        if (isNonNativeEvent(type, this._actions)) {\n          this.events[method](type, listener)\n        }\n        // delegated event\n        else if (is.string(this.target)) {\n          this._scopeEvents[`${addRemove}Delegate` as 'addDelegate' | 'removeDelegate'](this.target, this._context, type, listener, options)\n        }\n        // remove listener from this Interactable's element\n        else {\n          this._scopeEvents[addRemove](this.target, type, listener, options)\n        }\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Binds a listener for an InteractEvent, pointerEvent or DOM event.\n   *\n   * @param {string | array | object} types The types of events to listen\n   * for\n   * @param {function | array | object} [listener] The event listener function(s)\n   * @param {object | boolean} [options] options object or useCapture flag for\n   * addEventListener\n   * @return {Interactable} This Interactable\n   */\n  on (types: Interact.EventTypes, listener?: Interact.ListenersArg, options?: any) {\n    return this._onOff('on', types, listener, options)\n  }\n\n  /**\n   * Removes an InteractEvent, pointerEvent or DOM event listener.\n   *\n   * @param {string | array | object} types The types of events that were\n   * listened for\n   * @param {function | array | object} [listener] The event listener function(s)\n   * @param {object | boolean} [options] options object or useCapture flag for\n   * removeEventListener\n   * @return {Interactable} This Interactable\n   */\n  off (types: string | string[] | Interact.EventTypes, listener?: Interact.ListenersArg, options?: any) {\n    return this._onOff('off', types, listener, options)\n  }\n\n  /**\n   * Reset the options of this Interactable\n   *\n   * @param {object} options The new settings to apply\n   * @return {object} This Interactable\n   */\n  set (options: Interact.OptionsArg) {\n    const defaults = this._defaults\n\n    if (!is.object(options)) {\n      options = {}\n    }\n\n    (this.options as Required<Options>) = clone(defaults.base) as Required<Options>\n\n    for (const actionName_ in this._actions.methodDict) {\n      const actionName = actionName_ as Interact.ActionName\n      const methodName = this._actions.methodDict[actionName]\n\n      this.options[actionName] = {}\n      this.setPerAction(actionName, extend(extend({}, defaults.perAction), defaults.actions[actionName]))\n\n      this[methodName](options[actionName])\n    }\n\n    for (const setting in options) {\n      if (is.func(this[setting])) {\n        this[setting](options[setting])\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Remove this interactable from the list of interactables and remove it's\n   * action capabilities and event listeners\n   */\n  unset () {\n    if (is.string(this.target)) {\n      // remove delegated events\n      for (const type in this._scopeEvents.delegatedEvents) {\n        const delegated = this._scopeEvents.delegatedEvents[type]\n\n        for (let i = delegated.length - 1; i >= 0; i--) {\n          const { selector, context, listeners } = delegated[i]\n\n          if (selector === this.target && context === this._context) {\n            delegated.splice(i, 1)\n          }\n\n          for (let l = listeners.length - 1; l >= 0; l--) {\n            this._scopeEvents.removeDelegate(this.target, this._context, type, listeners[l][0], listeners[l][1])\n          }\n        }\n      }\n    }\n    else {\n      this._scopeEvents.remove(this.target as Node, 'all')\n    }\n  }\n}\n\nexport default Interactable\n"
	]
}