{
	"version": 3,
	"sources": [
		"Interaction.ts"
	],
	"names": [
		"utils",
		"InteractEvent",
		"PointerInfo",
		"_ProxyValues",
		"_ProxyMethods",
		"idCounter",
		"Interaction",
		"pointerMoveTolerance",
		"constructor",
		"pointerType",
		"scopeFire",
		"this",
		"interactable",
		"element",
		"rect",
		"_rects",
		"edges",
		"_scopeFire",
		"prepared",
		"name",
		"axis",
		"pointers",
		"downEvent",
		"downPointer",
		"_latestPointer",
		"pointer",
		"event",
		"eventTarget",
		"prevEvent",
		"pointerIsDown",
		"pointerWasMoved",
		"_interacting",
		"_ending",
		"_stopped",
		"_proxy",
		"simulation",
		"doMove",
		"warnOnce",
		"signalArg",
		"move",
		"coords",
		"start",
		"newCoords",
		"prev",
		"cur",
		"delta",
		"velocity",
		"_id",
		"that",
		"key",
		"Object",
		"defineProperty",
		"get",
		"value",
		"args",
		"interaction",
		"pointerDown",
		"pointerIndex",
		"updatePointer",
		"pointerInfo",
		"type",
		"action",
		"interacting",
		"length",
		"options",
		"enabled",
		"copyAction",
		"getRect",
		"extend",
		"left",
		"right",
		"top",
		"bottom",
		"_doPhase",
		"phase",
		"pointerMove",
		"modification",
		"endResult",
		"duplicateMove",
		"page",
		"x",
		"y",
		"client",
		"dx",
		"dy",
		"hypot",
		"getPointerIndex",
		"duplicate",
		"setCoordVelocity",
		"copyCoords",
		"setZeroCoords",
		"pointerUp",
		"curEventTarget",
		"test",
		"end",
		"removePointer",
		"documentBlur",
		"endPhaseResult",
		"stop",
		"currentAction",
		"pointerId",
		"getPointerId",
		"arr",
		"findIndex",
		"curPointer",
		"id",
		"getPointerInfo",
		"down",
		"push",
		"setCoords",
		"map",
		"p",
		"_now",
		"setCoordDeltas",
		"downTime",
		"timeStamp",
		"downTarget",
		"pointerExtend",
		"_updateLatestPointer",
		"splice",
		"destroy",
		"_createPreparedEvent",
		"preEnd",
		"_fireEvent",
		"iEvent",
		"fire",
		"addEdges",
		"deltaSource",
		"width",
		"height",
		"Date",
		"now"
	],
	"mappings": "UAAYA,MAAW,+BAChBC,MAAmC,gCAEnCC,MAAiB,8BAaxB,IAAYC,cAAAA,IAAAA,kBAAAA,aAAAA,cAAAA,mBAAAA,qBAAAA,cAAAA,eAAAA,yBASZ,IAAYC,eAAAA,IAAAA,WAAAA,UAAAA,SAAAA,UAAAA,mBAAAA,gBAAAA,mBAuEZ,IAAIC,EAAY,SAET,MAAMC,YAwDXC,2BACE,OAAO,EA4BTC,aAAaC,YAAEA,EAAFC,UAAeA,IAGzBC,KAtFHC,aAA6B,KAsF1BD,KAnFHE,QAA4B,KAmFzBF,KAlFHG,UAkFG,EAAAH,KAjFHI,YAiFG,EAAAJ,KA3EHK,WA2EG,EAAAL,KAzEHM,gBAyEG,EAAAN,KAtEHO,SAA2B,CACzBC,KAAO,KACPC,KAAO,KACPJ,MAAO,MAmENL,KAhEHF,iBAgEG,EAAAE,KA7DHU,SAA0B,GA6DvBV,KA1DHW,UAAuC,KA0DpCX,KAxDHY,YAAoC,GAwDjCZ,KAtDHa,eAII,CACFC,QAAS,KACTC,MAAO,KACPC,YAAa,MA+CZhB,KA3CHiB,UAA0C,KA2CvCjB,KAzCHkB,eAAgB,EAyCblB,KAxCHmB,iBAAkB,EAwCfnB,KAvCHoB,cAAe,EAuCZpB,KAtCHqB,SAAU,EAsCPrB,KArCHsB,UAAW,EAqCRtB,KApCHuB,OAA8B,KAoC3BvB,KAlCHwB,WAAa,KAkCVxB,KAzBHyB,OAASpC,EAAMqC,UACb,SAA6BC,GAC3B3B,KAAK4B,KAAKD,KAEZ,0EAqBC3B,KAnBH6B,OAA6B,CAE3BC,MAAOzC,EAAMyB,QAAQiB,YAErBC,KAAM3C,EAAMyB,QAAQiB,YAEpBE,IAAK5C,EAAMyB,QAAQiB,YAEnBG,MAAO7C,EAAMyB,QAAQiB,YAErBI,SAAU9C,EAAMyB,QAAQiB,aASvB/B,KANMoC,IAAc1C,IAOrBM,KAAKM,WAAaP,EAClBC,KAAKF,YAAcA,EAEnB,MAAMuC,EAAOrC,KAEbA,KAAKuB,OAAS,GAEd,IAAK,MAAMe,KAAO9C,aAChB+C,OAAOC,eAAexC,KAAKuB,OAAQe,EAAK,CACtCG,IAAG,IAAaJ,EAAKC,KAIzB,IAAK,MAAMA,KAAO7C,cAChB8C,OAAOC,eAAexC,KAAKuB,OAAQe,EAAK,CACtCI,SAAWC,GAASN,OAAAA,EAAKC,MAAQK,MAIrC3C,KAAKM,WAAW,mBAAoB,CAAEsC,YAAa5C,OAGrD6C,YAAa/B,EAA+BC,EAAkCC,GAC5E,MAAM8B,EAAe9C,KAAK+C,cAAcjC,EAASC,EAAOC,GAAa,GAC/DgC,EAAchD,KAAKU,SAASoC,GAElC9C,KAAKM,WAAW,oBAAqB,CACnCQ,QAAAA,EACAC,MAAAA,EACAC,YAAAA,EACA8B,aAAAA,EACAE,YAAAA,EACAC,KAAM,OACNL,YAAa5C,OAmCjB8B,MAAOoB,EAAqBjD,EAA4BC,GACtD,QAAIF,KAAKmD,gBACJnD,KAAKkB,eACNlB,KAAKU,SAAS0C,QAA0B,YAAhBF,EAAO1C,KAAqB,EAAI,KACvDP,EAAaoD,QAAQH,EAAO1C,MAAM8C,WAIvCjE,EAAMkE,WAAWvD,KAAKO,SAAU2C,GAEhClD,KAAKC,aAAeA,EACpBD,KAAKE,QAAeA,EACpBF,KAAKG,KAAeF,EAAauD,QAAQtD,GACzCF,KAAKK,MAAeL,KAAKO,SAASF,MAC9BhB,EAAMoE,OAAO,GAAIzD,KAAKO,SAASF,OAC/B,CAAEqD,MAAM,EAAMC,OAAO,EAAMC,KAAK,EAAMC,QAAQ,GAClD7D,KAAKsB,UAAe,EACpBtB,KAAKoB,aAAepB,KAAK8D,SAAS,CAChClB,YAAa5C,KACbe,MAAOf,KAAKW,UACZoD,MAAO,YACF/D,KAAKsB,SAELtB,KAAKoB,cAGd4C,YAAalD,EAA+BC,EAAkCC,GACvEhB,KAAKwB,YAAgBxB,KAAKiE,cAAgBjE,KAAKiE,aAAaC,WAC/DlE,KAAK+C,cAAcjC,EAASC,EAAOC,GAAa,GAGlD,MAAMmD,EAAiBnE,KAAK6B,OAAOI,IAAImC,KAAKC,IAAMrE,KAAK6B,OAAOG,KAAKoC,KAAKC,GACjDrE,KAAK6B,OAAOI,IAAImC,KAAKE,IAAMtE,KAAK6B,OAAOG,KAAKoC,KAAKE,GACjDtE,KAAK6B,OAAOI,IAAIsC,OAAOF,IAAMrE,KAAK6B,OAAOG,KAAKuC,OAAOF,GACrDrE,KAAK6B,OAAOI,IAAIsC,OAAOD,IAAMtE,KAAK6B,OAAOG,KAAKuC,OAAOD,EAE5E,IAAIE,EACAC,EAGAzE,KAAKkB,gBAAkBlB,KAAKmB,kBAC9BqD,EAAKxE,KAAK6B,OAAOI,IAAIsC,OAAOF,EAAIrE,KAAK6B,OAAOC,MAAMyC,OAAOF,EACzDI,EAAKzE,KAAK6B,OAAOI,IAAIsC,OAAOD,EAAItE,KAAK6B,OAAOC,MAAMyC,OAAOD,EAEzDtE,KAAKmB,gBAAkB9B,EAAMqF,MAAMF,EAAIC,GAAMzE,KAAKJ,sBAGpD,MAAMkD,EAAe9C,KAAK2E,gBAAgB7D,GACpCa,EAAY,CAChBb,QAAAA,EACAgC,aAAAA,EACAE,YAAahD,KAAKU,SAASoC,GAC3B/B,MAAAA,EACAkC,KAAM,OACNjC,YAAAA,EACAwD,GAAAA,EACAC,GAAAA,EACAG,UAAWT,EACXvB,YAAa5C,MAGVmE,GAEH9E,EAAMyB,QAAQ+D,iBAAiB7E,KAAK6B,OAAOM,SAAUnC,KAAK6B,OAAOK,OAGnElC,KAAKM,WAAW,oBAAqBqB,GAEhCwC,GAAkBnE,KAAKwB,aAEtBxB,KAAKmD,gBACPxB,EAAUsB,KAAO,KACjBjD,KAAK4B,KAAKD,IAGR3B,KAAKmB,iBACP9B,EAAMyB,QAAQgE,WAAW9E,KAAK6B,OAAOG,KAAMhC,KAAK6B,OAAOI,MAuB7DL,KAAMD,GACCA,GAAcA,EAAUZ,OAC3B1B,EAAMyB,QAAQiE,cAAc/E,KAAK6B,OAAOK,QAG1CP,EAAYtC,EAAMoE,OAAO,CACvB3C,QAASd,KAAKa,eAAeC,QAC7BC,MAAOf,KAAKa,eAAeE,MAC3BC,YAAahB,KAAKa,eAAeG,YACjC4B,YAAa5C,MACZ2B,GAAa,KAENoC,MAAQ,OAElB/D,KAAK8D,SAASnC,GAIhBqD,UAAWlE,EAA+BC,EAAkCC,EAAmCiE,GAC7G,IAAInC,EAAe9C,KAAK2E,gBAAgB7D,IAElB,IAAlBgC,IACFA,EAAe9C,KAAK+C,cAAcjC,EAASC,EAAOC,GAAa,IAGjE,MAAMiC,EAAO,WAAWiC,KAAKnE,EAAMkC,MAAQ,SAAW,KAEtDjD,KAAKM,WAAY,gBAAe2C,IAAqD,CACnFnC,QAAAA,EACAgC,aAAAA,EACAE,YAAahD,KAAKU,SAASoC,GAC3B/B,MAAAA,EACAC,YAAAA,EACAiC,KAAMA,EACNgC,eAAAA,EACArC,YAAa5C,OAGVA,KAAKwB,YACRxB,KAAKmF,IAAIpE,GAGXf,KAAKkB,eAAgB,EACrBlB,KAAKoF,cAActE,EAASC,GAG9BsE,aAActE,GACZf,KAAKmF,IAAIpE,GACTf,KAAKM,WAAW,oBAAqB,CAAES,MAAAA,EAAOkC,KAAM,OAAQL,YAAa5C,OAmB3EmF,IAAKpE,GAGH,IAAIuE,EAFJtF,KAAKqB,SAAU,EACfN,EAAQA,GAASf,KAAKa,eAAeE,MAGjCf,KAAKmD,gBACPmC,EAAiBtF,KAAK8D,SAAS,CAC7B/C,MAAAA,EACA6B,YAAa5C,KACb+D,MAAO,SAIX/D,KAAKqB,SAAU,GAEQ,IAAnBiE,GACFtF,KAAKuF,OAITC,gBACE,OAAOxF,KAAKoB,aAAepB,KAAKO,SAASC,KAAO,KAGlD2C,cACE,OAAOnD,KAAKoB,aAIdmE,OACEvF,KAAKM,WAAW,oBAAqB,CAAEsC,YAAa5C,OAEpDA,KAAKC,aAAeD,KAAKE,QAAU,KAEnCF,KAAKoB,cAAe,EACpBpB,KAAKsB,UAAW,EAChBtB,KAAKO,SAASC,KAAOR,KAAKiB,UAAY,KAGxC0D,gBAAiB7D,GACf,MAAM2E,EAAYpG,EAAMyB,QAAQ4E,aAAa5E,GAG7C,MAA6B,UAArBd,KAAKF,aAAgD,QAArBE,KAAKF,YACzCE,KAAKU,SAAS0C,OAAS,EACvB/D,EAAMsG,IAAIC,UAAU5F,KAAKU,SAAUmF,GAAcA,EAAWC,KAAOL,GAGzEM,eAAgBjF,GACd,OAAOd,KAAKU,SAASV,KAAK2E,gBAAgB7D,IAG5CiC,cAAejC,EAA+BC,EAAkCC,EAAmCgF,GACjH,MAAMF,EAAKzG,EAAMyB,QAAQ4E,aAAa5E,GACtC,IAAIgC,EAAe9C,KAAK2E,gBAAgB7D,GACpCkC,EAAchD,KAAKU,SAASoC,GAqDhC,OAnDAkD,GAAgB,IAATA,IAEHA,GAAQ,iBAAiBd,KAAKnE,EAAMkC,OAEnCD,EAaHA,EAAYlC,QAAUA,GAZtBkC,EAAc,IAAIzD,EAChBuG,EACAhF,EACAC,EACA,KACA,MAGF+B,EAAe9C,KAAKU,SAAS0C,OAC7BpD,KAAKU,SAASuF,KAAKjD,IAMrB3D,EAAMyB,QAAQoF,UAAUlG,KAAK6B,OAAOI,IAAKjC,KAAKU,SAASyF,IAAIC,GAAKA,EAAEtF,SAAUd,KAAKqG,QACjFhH,EAAMyB,QAAQwF,eAAetG,KAAK6B,OAAOK,MAAOlC,KAAK6B,OAAOG,KAAMhC,KAAK6B,OAAOI,KAE1E+D,IACFhG,KAAKkB,eAAgB,EAErB8B,EAAYuD,SAAWvG,KAAK6B,OAAOI,IAAIuE,UACvCxD,EAAYyD,WAAazF,EACzB3B,EAAMyB,QAAQ4F,cAAc1G,KAAKY,YAAaE,GAEzCd,KAAKmD,gBACR9D,EAAMyB,QAAQgE,WAAW9E,KAAK6B,OAAOC,MAAO9B,KAAK6B,OAAOI,KACxD5C,EAAMyB,QAAQgE,WAAW9E,KAAK6B,OAAOG,KAAMhC,KAAK6B,OAAOI,KAEvDjC,KAAKW,UAAYI,EACjBf,KAAKmB,iBAAkB,IAI3BnB,KAAK2G,qBAAqB7F,EAASC,EAAOC,GAE1ChB,KAAKM,WAAW,8BAA+B,CAC7CQ,QAAAA,EACAC,MAAAA,EACAC,YAAAA,EACAgF,KAAAA,EACAhD,YAAAA,EACAF,aAAAA,EACAF,YAAa5C,OAGR8C,EAGTsC,cAAetE,EAA+BC,GAC5C,MAAM+B,EAAe9C,KAAK2E,gBAAgB7D,GAE1C,IAAsB,IAAlBgC,EAAuB,OAE3B,MAAME,EAAchD,KAAKU,SAASoC,GAElC9C,KAAKM,WAAW,8BAA+B,CAC7CQ,QAAAA,EACAC,MAAAA,EACAC,YAAa,KACb8B,aAAAA,EACAE,YAAAA,EACAJ,YAAa5C,OAGfA,KAAKU,SAASkG,OAAO9D,EAAc,GAGrC6D,qBAAsB7F,EAASC,EAAOC,GACpChB,KAAKa,eAAeC,QAAUA,EAC9Bd,KAAKa,eAAeE,MAAQA,EAC5Bf,KAAKa,eAAeG,YAAcA,EAGpC6F,UACE7G,KAAKa,eAAeC,QAAU,KAC9Bd,KAAKa,eAAeE,MAAQ,KAC5Bf,KAAKa,eAAeG,YAAc,KAGpC8F,qBAA4C/F,EAAkCgD,EAAUgD,EAAkB9D,GACxG,OAAO,IAAI3D,EAAoBU,KAAMe,EAAOf,KAAKO,SAASC,KAAMuD,EAAO/D,KAAKE,QAAS6G,EAAQ9D,GAG/F+D,WAAkCC,GAChCjH,KAAKC,aAAaiH,KAAKD,KAElBjH,KAAKiB,WAAagG,EAAOT,WAAaxG,KAAKiB,UAAUuF,aACxDxG,KAAKiB,UAAYgG,GAIrBnD,SAAgCnC,GAC9B,MAAMZ,MAAEA,EAAFgD,MAASA,EAATgD,OAAgBA,EAAhB9D,KAAwBA,GAAStB,GACjCxB,KAAEA,GAASH,KAYjB,GAVIG,GAAkB,SAAV4D,IAEV1E,EAAMc,KAAKgH,SAASnH,KAAKK,MAAOF,EAAMH,KAAK6B,OAAOK,MAAMlC,KAAKC,aAAaoD,QAAQ+D,cAElFjH,EAAKkH,MAAQlH,EAAKwD,MAAQxD,EAAKuD,KAC/BvD,EAAKmH,OAASnH,EAAK0D,OAAS1D,EAAKyD,MAKd,IAFA5D,KAAKM,WAAY,8BAA6ByD,IAAgBpC,GAGjF,OAAO,EAGT,MAAMsF,EAAStF,EAAUsF,OAASjH,KAAK8G,qBAAqB/F,EAAOgD,EAAOgD,EAAQ9D,GAUlF,OARAjD,KAAKM,WAAY,uBAAsByD,IAAgBpC,GAEzC,UAAVoC,IAAqB/D,KAAKiB,UAAYgG,GAE1CjH,KAAKgH,WAAWC,GAEhBjH,KAAKM,WAAY,6BAA4ByD,IAAgBpC,IAEtD,EAGT0E,OAAU,OAAOkB,KAAKC,sBAGT7H,mBACNJ",
	"sourcesContent": [
		"import * as utils from '@interactjs/utils/index'\nimport InteractEvent, { EventPhase } from './InteractEvent'\nimport Interactable from './Interactable'\nimport PointerInfo from './PointerInfo'\nimport { ActionName } from './scope'\n\nexport interface ActionProps<T extends ActionName = Interact.ActionName> {\n  name: T\n  axis?: 'x' | 'y' | 'xy'\n  edges?: Interact.EdgeOptions\n}\n\nexport interface StartAction extends ActionProps {\n  name: ActionName\n}\n\nexport enum _ProxyValues {\n  interactable = '',\n  element = '',\n  prepared = '',\n  pointerIsDown = '',\n  pointerWasMoved = '',\n  _proxy = ''\n}\n\nexport enum _ProxyMethods {\n  start = '',\n  move = '',\n  end = '',\n  stop = '',\n  interacting = ''\n}\n\nexport type PointerArgProps<T extends {} = {}> = {\n  pointer: Interact.PointerType\n  event: Interact.PointerEventType\n  eventTarget: Interact.EventTarget\n  pointerIndex: number\n  pointerInfo: PointerInfo\n  interaction: Interaction\n} & T\n\nexport interface DoPhaseArg<T extends ActionName, P extends EventPhase> {\n  event: Interact.PointerEventType\n  phase: EventPhase\n  interaction: Interaction<T>\n  iEvent: InteractEvent<T, P>\n  preEnd?: boolean\n  type?: string\n}\n\nexport type DoAnyPhaseArg = DoPhaseArg<ActionName, EventPhase>\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactions:new': { interaction: Interaction }\n    'interactions:down': PointerArgProps<{\n      type: 'down'\n    }>\n    'interactions:move': PointerArgProps<{\n      type: 'move'\n      dx: number\n      dy: number\n      duplicate: boolean\n    }>\n    'interactions:up': PointerArgProps<{\n      type: 'up'\n      curEventTarget: EventTarget\n    }>\n    'interactions:cancel': SignalArgs['interactions:up'] & {\n      type: 'cancel'\n      curEventTarget: EventTarget\n    }\n    'interactions:update-pointer': PointerArgProps<{\n      down: boolean\n    }>\n    'interactions:remove-pointer': PointerArgProps\n    'interactions:blur'\n    'interactions:before-action-start': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-start': DoAnyPhaseArg\n    'interactions:after-action-start': DoAnyPhaseArg\n    'interactions:before-action-move': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-move': DoAnyPhaseArg\n    'interactions:after-action-move': DoAnyPhaseArg\n    'interactions:before-action-end': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-end': DoAnyPhaseArg\n    'interactions:after-action-end': DoAnyPhaseArg\n    'interactions:stop': { interaction: Interaction }\n  }\n}\n\nexport type InteractionProxy<T extends ActionName = ActionName> = Pick<\nInteraction<T>,\nkeyof typeof _ProxyValues | keyof typeof _ProxyMethods\n>\n\nlet idCounter = 0\n\nexport class Interaction<T extends ActionName = ActionName> {\n  // current interactable being interacted with\n  interactable: Interactable = null\n\n  // the target element of the interactable\n  element: Interact.Element = null\n  rect: Interact.FullRect\n  _rects?: {\n    start: Interact.FullRect\n    corrected: Interact.FullRect\n    previous: Interact.FullRect\n    delta: Interact.FullRect\n  }\n  edges: Interact.EdgeOptions\n\n  _scopeFire: Interact.Scope['fire']\n\n  // action that's ready to be fired on next move event\n  prepared: ActionProps<T> = {\n    name : null,\n    axis : null,\n    edges: null,\n  }\n\n  pointerType: string\n\n  // keep track of added pointers\n  pointers: PointerInfo[] = []\n\n  // pointerdown/mousedown/touchstart event\n  downEvent: Interact.PointerEventType = null\n\n  downPointer: Interact.PointerType = {} as Interact.PointerType\n\n  _latestPointer: {\n    pointer: Interact.PointerType\n    event: Interact.PointerEventType\n    eventTarget: Node\n  } = {\n    pointer: null,\n    event: null,\n    eventTarget: null,\n  }\n\n  // previous action event\n  prevEvent: InteractEvent<T, EventPhase> = null\n\n  pointerIsDown = false\n  pointerWasMoved = false\n  _interacting = false\n  _ending = false\n  _stopped = true\n  _proxy: InteractionProxy<T> = null\n\n  simulation = null\n\n  get pointerMoveTolerance () {\n    return 1\n  }\n\n  /**\n   * @alias Interaction.prototype.move\n   */\n  doMove = utils.warnOnce(\n    function (this: Interaction, signalArg: any) {\n      this.move(signalArg)\n    },\n    'The interaction.doMove() method has been renamed to interaction.move()')\n\n  coords: Interact.CoordsSet = {\n    // Starting InteractEvent pointer coordinates\n    start: utils.pointer.newCoords(),\n    // Previous native pointer move event coordinates\n    prev: utils.pointer.newCoords(),\n    // current native pointer move event coordinates\n    cur: utils.pointer.newCoords(),\n    // Change in coordinates and time of the pointer\n    delta: utils.pointer.newCoords(),\n    // pointer velocity\n    velocity: utils.pointer.newCoords(),\n  }\n\n  readonly _id: number = idCounter++\n\n  /** */\n  constructor ({ pointerType, scopeFire }: {\n    pointerType?: string\n    scopeFire: Interact.Scope['fire']\n  }) {\n    this._scopeFire = scopeFire\n    this.pointerType = pointerType\n\n    const that = this\n\n    this._proxy = {} as InteractionProxy<T>\n\n    for (const key in _ProxyValues) {\n      Object.defineProperty(this._proxy, key, {\n        get () { return that[key] },\n      })\n    }\n\n    for (const key in _ProxyMethods) {\n      Object.defineProperty(this._proxy, key, {\n        value: (...args) => that[key](...args),\n      })\n    }\n\n    this._scopeFire('interactions:new', { interaction: this })\n  }\n\n  pointerDown (pointer: Interact.PointerType, event: Interact.PointerEventType, eventTarget: Interact.EventTarget) {\n    const pointerIndex = this.updatePointer(pointer, event, eventTarget, true)\n    const pointerInfo = this.pointers[pointerIndex]\n\n    this._scopeFire('interactions:down', {\n      pointer,\n      event,\n      eventTarget,\n      pointerIndex,\n      pointerInfo,\n      type: 'down',\n      interaction: this,\n    })\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable({\n   *     // disable the default drag start by down->move\n   *     manualStart: true\n   *   })\n   *   // start dragging after the user holds the pointer down\n   *   .on('hold', function (event) {\n   *     var interaction = event.interaction\n   *\n   *     if (!interaction.interacting()) {\n   *       interaction.start({ name: 'drag' },\n   *                         event.interactable,\n   *                         event.currentTarget)\n   *     }\n   * })\n   * ```\n   *\n   * Start an action with the given Interactable and Element as tartgets. The\n   * action must be enabled for the target Interactable and an appropriate\n   * number of pointers must be held down - 1 for drag/resize, 2 for gesture.\n   *\n   * Use it with `interactable.<action>able({ manualStart: false })` to always\n   * [start actions manually](https://github.com/taye/interact.js/issues/114)\n   *\n   * @param {object} action   The action to be performed - drag, resize, etc.\n   * @param {Interactable} target  The Interactable to target\n   * @param {Element} element The DOM Element to target\n   * @return {object} interact\n   */\n  start (action: StartAction, interactable: Interactable, element: Interact.Element) {\n    if (this.interacting() ||\n        !this.pointerIsDown ||\n        this.pointers.length < (action.name === 'gesture' ? 2 : 1) ||\n        !interactable.options[action.name].enabled) {\n      return false\n    }\n\n    utils.copyAction(this.prepared, action)\n\n    this.interactable = interactable\n    this.element      = element\n    this.rect         = interactable.getRect(element)\n    this.edges        = this.prepared.edges\n      ? utils.extend({}, this.prepared.edges)\n      : { left: true, right: true, top: true, bottom: true }\n    this._stopped     = false\n    this._interacting = this._doPhase({\n      interaction: this,\n      event: this.downEvent,\n      phase: 'start',\n    }) && !this._stopped\n\n    return this._interacting\n  }\n\n  pointerMove (pointer: Interact.PointerType, event: Interact.PointerEventType, eventTarget: Interact.EventTarget) {\n    if (!this.simulation && !(this.modification && this.modification.endResult)) {\n      this.updatePointer(pointer, event, eventTarget, false)\n    }\n\n    const duplicateMove = (this.coords.cur.page.x === this.coords.prev.page.x &&\n                           this.coords.cur.page.y === this.coords.prev.page.y &&\n                           this.coords.cur.client.x === this.coords.prev.client.x &&\n                           this.coords.cur.client.y === this.coords.prev.client.y)\n\n    let dx\n    let dy\n\n    // register movement greater than pointerMoveTolerance\n    if (this.pointerIsDown && !this.pointerWasMoved) {\n      dx = this.coords.cur.client.x - this.coords.start.client.x\n      dy = this.coords.cur.client.y - this.coords.start.client.y\n\n      this.pointerWasMoved = utils.hypot(dx, dy) > this.pointerMoveTolerance\n    }\n\n    const pointerIndex = this.getPointerIndex(pointer)\n    const signalArg = {\n      pointer,\n      pointerIndex,\n      pointerInfo: this.pointers[pointerIndex],\n      event,\n      type: 'move' as const,\n      eventTarget,\n      dx,\n      dy,\n      duplicate: duplicateMove,\n      interaction: this,\n    }\n\n    if (!duplicateMove) {\n      // set pointer coordinate, time changes and velocity\n      utils.pointer.setCoordVelocity(this.coords.velocity, this.coords.delta)\n    }\n\n    this._scopeFire('interactions:move', signalArg)\n\n    if (!duplicateMove && !this.simulation) {\n      // if interacting, fire an 'action-move' signal etc\n      if (this.interacting()) {\n        signalArg.type = null\n        this.move(signalArg)\n      }\n\n      if (this.pointerWasMoved) {\n        utils.pointer.copyCoords(this.coords.prev, this.coords.cur)\n      }\n    }\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable(true)\n   *   .on('dragmove', function (event) {\n   *     if (someCondition) {\n   *       // change the snap settings\n   *       event.interactable.draggable({ snap: { targets: [] }})\n   *       // fire another move event with re-calculated snap\n   *       event.interaction.move()\n   *     }\n   *   })\n   * ```\n   *\n   * Force a move of the current action at the same coordinates. Useful if\n   * snap/restrict has been changed and you want a movement with the new\n   * settings.\n   */\n  move (signalArg?) {\n    if (!signalArg || !signalArg.event) {\n      utils.pointer.setZeroCoords(this.coords.delta)\n    }\n\n    signalArg = utils.extend({\n      pointer: this._latestPointer.pointer,\n      event: this._latestPointer.event,\n      eventTarget: this._latestPointer.eventTarget,\n      interaction: this,\n    }, signalArg || {})\n\n    signalArg.phase = 'move'\n\n    this._doPhase(signalArg)\n  }\n\n  // End interact move events and stop auto-scroll unless simulation is running\n  pointerUp (pointer: Interact.PointerType, event: Interact.PointerEventType, eventTarget: Interact.EventTarget, curEventTarget: Interact.EventTarget) {\n    let pointerIndex = this.getPointerIndex(pointer)\n\n    if (pointerIndex === -1) {\n      pointerIndex = this.updatePointer(pointer, event, eventTarget, false)\n    }\n\n    const type = /cancel$/i.test(event.type) ? 'cancel' : 'up'\n\n    this._scopeFire(`interactions:${type}` as 'interactions:up' | 'interactions:cancel', {\n      pointer,\n      pointerIndex,\n      pointerInfo: this.pointers[pointerIndex],\n      event,\n      eventTarget,\n      type: type as any,\n      curEventTarget,\n      interaction: this,\n    })\n\n    if (!this.simulation) {\n      this.end(event)\n    }\n\n    this.pointerIsDown = false\n    this.removePointer(pointer, event)\n  }\n\n  documentBlur (event) {\n    this.end(event)\n    this._scopeFire('interactions:blur', { event, type: 'blur', interaction: this })\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable(true)\n   *   .on('move', function (event) {\n   *     if (event.pageX > 1000) {\n   *       // end the current action\n   *       event.interaction.end()\n   *       // stop all further listeners from being called\n   *       event.stopImmediatePropagation()\n   *     }\n   *   })\n   * ```\n   *\n   * @param {PointerEvent} [event]\n   */\n  end (event?: Interact.PointerEventType) {\n    this._ending = true\n    event = event || this._latestPointer.event\n    let endPhaseResult\n\n    if (this.interacting()) {\n      endPhaseResult = this._doPhase({\n        event,\n        interaction: this,\n        phase: 'end',\n      })\n    }\n\n    this._ending = false\n\n    if (endPhaseResult === true) {\n      this.stop()\n    }\n  }\n\n  currentAction () {\n    return this._interacting ? this.prepared.name : null\n  }\n\n  interacting () {\n    return this._interacting\n  }\n\n  /** */\n  stop () {\n    this._scopeFire('interactions:stop', { interaction: this })\n\n    this.interactable = this.element = null\n\n    this._interacting = false\n    this._stopped = true\n    this.prepared.name = this.prevEvent = null\n  }\n\n  getPointerIndex (pointer) {\n    const pointerId = utils.pointer.getPointerId(pointer)\n\n    // mouse and pen interactions may have only one pointer\n    return (this.pointerType === 'mouse' || this.pointerType === 'pen')\n      ? this.pointers.length - 1\n      : utils.arr.findIndex(this.pointers, curPointer => curPointer.id === pointerId)\n  }\n\n  getPointerInfo (pointer) {\n    return this.pointers[this.getPointerIndex(pointer)]\n  }\n\n  updatePointer (pointer: Interact.PointerType, event: Interact.PointerEventType, eventTarget: Interact.EventTarget, down?: boolean) {\n    const id = utils.pointer.getPointerId(pointer)\n    let pointerIndex = this.getPointerIndex(pointer)\n    let pointerInfo = this.pointers[pointerIndex]\n\n    down = down === false\n      ? false\n      : down || /(down|start)$/i.test(event.type)\n\n    if (!pointerInfo) {\n      pointerInfo = new PointerInfo(\n        id,\n        pointer,\n        event,\n        null,\n        null,\n      )\n\n      pointerIndex = this.pointers.length\n      this.pointers.push(pointerInfo)\n    }\n    else {\n      pointerInfo.pointer = pointer\n    }\n\n    utils.pointer.setCoords(this.coords.cur, this.pointers.map(p => p.pointer), this._now())\n    utils.pointer.setCoordDeltas(this.coords.delta, this.coords.prev, this.coords.cur)\n\n    if (down) {\n      this.pointerIsDown = true\n\n      pointerInfo.downTime = this.coords.cur.timeStamp\n      pointerInfo.downTarget = eventTarget\n      utils.pointer.pointerExtend(this.downPointer, pointer)\n\n      if (!this.interacting()) {\n        utils.pointer.copyCoords(this.coords.start, this.coords.cur)\n        utils.pointer.copyCoords(this.coords.prev, this.coords.cur)\n\n        this.downEvent = event\n        this.pointerWasMoved = false\n      }\n    }\n\n    this._updateLatestPointer(pointer, event, eventTarget)\n\n    this._scopeFire('interactions:update-pointer', {\n      pointer,\n      event,\n      eventTarget,\n      down,\n      pointerInfo,\n      pointerIndex,\n      interaction: this,\n    })\n\n    return pointerIndex\n  }\n\n  removePointer (pointer: Interact.PointerType, event: Interact.PointerEventType) {\n    const pointerIndex = this.getPointerIndex(pointer)\n\n    if (pointerIndex === -1) { return }\n\n    const pointerInfo = this.pointers[pointerIndex]\n\n    this._scopeFire('interactions:remove-pointer', {\n      pointer,\n      event,\n      eventTarget: null,\n      pointerIndex,\n      pointerInfo,\n      interaction: this,\n    })\n\n    this.pointers.splice(pointerIndex, 1)\n  }\n\n  _updateLatestPointer (pointer, event, eventTarget) {\n    this._latestPointer.pointer = pointer\n    this._latestPointer.event = event\n    this._latestPointer.eventTarget = eventTarget\n  }\n\n  destroy () {\n    this._latestPointer.pointer = null\n    this._latestPointer.event = null\n    this._latestPointer.eventTarget = null\n  }\n\n  _createPreparedEvent<P extends EventPhase> (event: Interact.PointerEventType, phase: P, preEnd?: boolean, type?: string) {\n    return new InteractEvent<T, P>(this, event, this.prepared.name, phase, this.element, preEnd, type)\n  }\n\n  _fireEvent<P extends EventPhase> (iEvent: InteractEvent<T, P>) {\n    this.interactable.fire(iEvent)\n\n    if (!this.prevEvent || iEvent.timeStamp >= this.prevEvent.timeStamp) {\n      this.prevEvent = iEvent\n    }\n  }\n\n  _doPhase<P extends EventPhase> (signalArg: Omit<DoPhaseArg<T, P>, 'iEvent'> & { iEvent?: InteractEvent<T, P> }) {\n    const { event, phase, preEnd, type } = signalArg\n    const { rect } = this\n\n    if (rect && phase === 'move') {\n      // update the rect changes due to pointer move\n      utils.rect.addEdges(this.edges, rect, this.coords.delta[this.interactable.options.deltaSource])\n\n      rect.width = rect.right - rect.left\n      rect.height = rect.bottom - rect.top\n    }\n\n    const beforeResult = this._scopeFire(`interactions:before-action-${phase}` as any, signalArg)\n\n    if (beforeResult === false) {\n      return false\n    }\n\n    const iEvent = signalArg.iEvent = this._createPreparedEvent(event, phase, preEnd, type)\n\n    this._scopeFire(`interactions:action-${phase}` as any, signalArg)\n\n    if (phase === 'start') { this.prevEvent = iEvent }\n\n    this._fireEvent(iEvent)\n\n    this._scopeFire(`interactions:after-action-${phase}` as any, signalArg)\n\n    return true\n  }\n\n  _now () { return Date.now() }\n}\n\nexport default Interaction\nexport { PointerInfo }\n"
	]
}