{
	"version": 3,
	"sources": [
		"index.ts"
	],
	"names": [
		"Interactable",
		"Scope",
		"utils",
		"drag",
		"DropEvent",
		"fireActivationEvents",
		"activeDrops",
		"event",
		"dropzone",
		"element",
		"slice",
		"target",
		"fire",
		"propagationStopped",
		"immediatePropagationStopped",
		"getActiveDrops",
		"scope",
		"dragElement",
		"interactables",
		"draggableElement",
		"drops",
		"list",
		"options",
		"drop",
		"enabled",
		"accept",
		"is",
		"string",
		"dom",
		"matchesSelector",
		"func",
		"dropElements",
		"_context",
		"querySelectorAll",
		"array",
		"dropzoneElement",
		"push",
		"collectDrops",
		"activeDrop",
		"rect",
		"getRect",
		"getDrop",
		"dropState",
		"interactable",
		"draggable",
		"dragEvent",
		"pointerEvent",
		"validDrops",
		"dropCheck",
		"dropIndex",
		"indexOfDeepestElement",
		"getDropEvents",
		"interaction",
		"_pointerEvent",
		"dropEvents",
		"enter",
		"leave",
		"activate",
		"deactivate",
		"move",
		"type",
		"rejected",
		"cur",
		"prev",
		"dragLeave",
		"prevDropzone",
		"dragEnter",
		"relatedTarget",
		"dragmove",
		"fireDropEvents",
		"events",
		"onEventCreated",
		"iEvent",
		"dynamicDrop",
		"dropResult",
		"id",
		"install",
		"actions",
		"interactStatic",
		"interact",
		"defaults",
		"usePlugin",
		"prototype",
		"object",
		"listeners",
		"normalized",
		"normalizeListeners",
		"corrected",
		"Object",
		"keys",
		"reduce",
		"acc",
		"test",
		"off",
		"on",
		"ondrop",
		"ondropactivate",
		"ondropdeactivate",
		"ondragenter",
		"ondragleave",
		"ondropmove",
		"overlap",
		"number",
		"Math",
		"max",
		"min",
		"checker",
		"bool",
		"dropzoneMethod",
		"this",
		"dropElement",
		"dropped",
		"dropOverlap",
		"origin",
		"getOriginXY",
		"page",
		"pointer",
		"getPageXY",
		"x",
		"y",
		"horizontal",
		"left",
		"right",
		"vertical",
		"top",
		"bottom",
		"dragRect",
		"cx",
		"width",
		"cy",
		"height",
		"overlapRatio",
		"dropCheckMethod",
		"newValue",
		"extend",
		"phaselessTypes",
		"dragenter",
		"dragleave",
		"dropactivate",
		"dropdeactivate",
		"dropmove",
		"methodDict",
		"[object Object]",
		"prepared",
		"name",
		"interactions:action-move",
		"interactions:action-end"
	],
	"mappings": "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",
	"sourcesContent": [
		"import InteractEvent from '@interactjs/core/InteractEvent'\nimport Interactable from '@interactjs/core/Interactable'\nimport Scope from '@interactjs/core/scope'\nimport * as utils from '@interactjs/utils/index'\nimport drag from '../drag'\nimport DropEvent from './DropEvent'\n\nexport interface DropzoneMethod {\n  (options: Interact.DropzoneOptions | boolean): Interact.Interactable\n  (): Interact.DropzoneOptions\n}\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    dropzone: DropzoneMethod\n    dropCheck: (\n      dragEvent: InteractEvent,\n      event: Interact.PointerEventType,\n      draggable: Interactable,\n      draggableElement: Interact.Element,\n      dropElemen: Interact.Element,\n      rect: any\n    ) => boolean\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    dropState?: DropState\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface ActionDefaults {\n    drop: Interact.DropzoneOptions\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface ActionMap {\n    drop?: typeof drop\n  }\n\n  interface Scope {\n    dynamicDrop?: boolean\n  }\n\n  interface SignalArgs {\n    'actions/drop:start': DropSignalArg\n    'actions/drop:move': DropSignalArg\n    'actions/drop:end': DropSignalArg\n  }\n}\n\ninterface DropSignalArg {\n  interaction: Interact.Interaction\n  dragEvent: Interact.DragEvent\n}\n\nexport interface ActiveDrop {\n  dropzone: Interactable\n  element: Interact.Element\n  rect: Interact.Rect\n}\n\nexport interface DropState {\n  cur: {\n    dropzone: Interactable    // the dropzone a drag target might be dropped into\n    element: Interact.Element // the element at the time of checking\n  }\n  prev: {\n    dropzone: Interactable    // the dropzone that was recently dragged away from\n    element: Interact.Element // the element at the time of checking\n  }\n  rejected: boolean           // wheather the potential drop was rejected from a listener\n  events: any                 // the drop events related to the current drag event\n  activeDrops: ActiveDrop[]\n}\n\nfunction install (scope: Scope) {\n  const {\n    actions,\n    /** @lends module:interact */\n    interactStatic: interact,\n    /** @lends Interactable */\n    Interactable, // eslint-disable-line no-shadow\n    defaults,\n  } = scope\n\n  scope.usePlugin(drag)\n\n  /**\n   *\n   * ```js\n   * interact('.drop').dropzone({\n   *   accept: '.can-drop' || document.getElementById('single-drop'),\n   *   overlap: 'pointer' || 'center' || zeroToOne\n   * }\n   * ```\n   *\n   * Returns or sets whether draggables can be dropped onto this target to\n   * trigger drop events\n   *\n   * Dropzones can receive the following events:\n   *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n   *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n   *  - `dragmove` when a draggable that has entered the dropzone is moved\n   *  - `drop` when a draggable is dropped into this dropzone\n   *\n   * Use the `accept` option to allow only elements that match the given CSS\n   * selector or element. The value can be:\n   *\n   *  - **an Element** - only that element can be dropped into this dropzone.\n   *  - **a string**, - the element being dragged must match it as a CSS selector.\n   *  - **`null`** - accept options is cleared - it accepts any element.\n   *\n   * Use the `overlap` option to set how drops are checked for. The allowed\n   * values are:\n   *\n   *   - `'pointer'`, the pointer must be over the dropzone (default)\n   *   - `'center'`, the draggable element's center must be over the dropzone\n   *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n   *   e.g. `0.5` for drop to happen when half of the area of the draggable is\n   *   over the dropzone\n   *\n   * Use the `checker` option to specify a function to check if a dragged element\n   * is over this Interactable.\n   *\n   * @param {boolean | object | null} [options] The new options to be set.\n   * @return {boolean | Interactable} The current setting or this Interactable\n   */\n  Interactable.prototype.dropzone = function (this: Interact.Interactable, options?: Interact.DropzoneOptions | boolean) {\n    return dropzoneMethod(this, options)\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   * .dropChecker(function(dragEvent,         // related dragmove or dragend event\n   *                       event,             // TouchEvent/PointerEvent/MouseEvent\n   *                       dropped,           // bool result of the default checker\n   *                       dropzone,          // dropzone Interactable\n   *                       dropElement,       // dropzone elemnt\n   *                       draggable,         // draggable Interactable\n   *                       draggableElement) {// draggable element\n   *\n   *   return dropped && event.target.hasAttribute('allow-drop')\n   * }\n   * ```\n   */\n  Interactable.prototype.dropCheck = function (this: Interact.Interactable, dragEvent, event, draggable, draggableElement, dropElement, rect) {\n    return dropCheckMethod(this, dragEvent, event, draggable, draggableElement, dropElement, rect)\n  }\n\n  /**\n   * Returns or sets whether the dimensions of dropzone elements are calculated\n   * on every dragmove or only on dragstart for the default dropChecker\n   *\n   * @param {boolean} [newValue] True to check on each move. False to check only\n   * before start\n   * @return {boolean | interact} The current setting or interact\n   */\n  interact.dynamicDrop = function (newValue?: boolean) {\n    if (utils.is.bool(newValue)) {\n      // if (dragging && scope.dynamicDrop !== newValue && !newValue) {\n      //  calcRects(dropzones)\n      // }\n\n      scope.dynamicDrop = newValue\n\n      return interact\n    }\n    return scope.dynamicDrop\n  }\n\n  utils.extend(actions.phaselessTypes, {\n    dragenter: true,\n    dragleave: true,\n    dropactivate: true,\n    dropdeactivate: true,\n    dropmove: true,\n    drop: true,\n  })\n  actions.methodDict.drop = 'dropzone'\n\n  scope.dynamicDrop = false\n\n  defaults.actions.drop = drop.defaults\n}\n\nfunction collectDrops ({ interactables }, draggableElement) {\n  const drops = []\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (const dropzone of interactables.list) {\n    if (!dropzone.options.drop.enabled) { continue }\n\n    const accept = dropzone.options.drop.accept\n\n    // test the draggable draggableElement against the dropzone's accept setting\n    if ((utils.is.element(accept) && accept !== draggableElement) ||\n        (utils.is.string(accept) &&\n        !utils.dom.matchesSelector(draggableElement, accept)) ||\n        (utils.is.func(accept) && !accept({ dropzone, draggableElement }))) {\n      continue\n    }\n\n    // query for new elements if necessary\n    const dropElements = utils.is.string(dropzone.target)\n      ? dropzone._context.querySelectorAll(dropzone.target)\n      : utils.is.array(dropzone.target) ? dropzone.target : [dropzone.target]\n\n    for (const dropzoneElement of dropElements) {\n      if (dropzoneElement !== draggableElement) {\n        drops.push({\n          dropzone,\n          element: dropzoneElement,\n        })\n      }\n    }\n  }\n\n  return drops\n}\n\nfunction fireActivationEvents (activeDrops, event) {\n  // loop through all active dropzones and trigger event\n  for (const { dropzone, element } of activeDrops.slice()) {\n    event.dropzone = dropzone\n\n    // set current element as event target\n    event.target = element\n    dropzone.fire(event)\n    event.propagationStopped = event.immediatePropagationStopped = false\n  }\n}\n\n// return a new array of possible drops. getActiveDrops should always be\n// called when a drag has just started or a drag event happens while\n// dynamicDrop is true\nfunction getActiveDrops (scope: Scope, dragElement: Interact.Element) {\n  // get dropzones and their elements that could receive the draggable\n  const activeDrops = collectDrops(scope, dragElement)\n\n  for (const activeDrop of activeDrops) {\n    activeDrop.rect = activeDrop.dropzone.getRect(activeDrop.element)\n  }\n\n  return activeDrops\n}\n\nfunction getDrop ({ dropState, interactable: draggable, element: dragElement }: Partial<Interact.Interaction>, dragEvent, pointerEvent) {\n  const validDrops = []\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (const { dropzone, element: dropzoneElement, rect } of dropState.activeDrops) {\n    validDrops.push(dropzone.dropCheck(dragEvent, pointerEvent, draggable, dragElement, dropzoneElement, rect)\n      ? dropzoneElement\n      : null)\n  }\n\n  // get the most appropriate dropzone based on DOM depth and order\n  const dropIndex = utils.dom.indexOfDeepestElement(validDrops)\n\n  return dropState.activeDrops[dropIndex] || null\n}\n\nfunction getDropEvents (interaction: Interact.Interaction, _pointerEvent, dragEvent) {\n  const { dropState } = interaction\n  const dropEvents = {\n    enter     : null,\n    leave     : null,\n    activate  : null,\n    deactivate: null,\n    move      : null,\n    drop      : null,\n  }\n\n  if (dragEvent.type === 'dragstart') {\n    dropEvents.activate = new DropEvent(dropState, dragEvent, 'dropactivate')\n\n    dropEvents.activate.target   = null\n    dropEvents.activate.dropzone = null\n  }\n  if (dragEvent.type === 'dragend') {\n    dropEvents.deactivate = new DropEvent(dropState, dragEvent, 'dropdeactivate')\n\n    dropEvents.deactivate.target   = null\n    dropEvents.deactivate.dropzone = null\n  }\n\n  if (dropState.rejected) {\n    return dropEvents\n  }\n\n  if (dropState.cur.element !== dropState.prev.element) {\n    // if there was a previous dropzone, create a dragleave event\n    if (dropState.prev.dropzone) {\n      dropEvents.leave = new DropEvent(dropState, dragEvent, 'dragleave')\n\n      dragEvent.dragLeave    = dropEvents.leave.target   = dropState.prev.element\n      dragEvent.prevDropzone = dropEvents.leave.dropzone = dropState.prev.dropzone\n    }\n    // if dropzone is not null, create a dragenter event\n    if (dropState.cur.dropzone) {\n      dropEvents.enter = new DropEvent(dropState, dragEvent, 'dragenter')\n\n      dragEvent.dragEnter = dropState.cur.element\n      dragEvent.dropzone = dropState.cur.dropzone\n    }\n  }\n\n  if (dragEvent.type === 'dragend' && dropState.cur.dropzone) {\n    dropEvents.drop = new DropEvent(dropState, dragEvent, 'drop')\n\n    dragEvent.dropzone = dropState.cur.dropzone\n    dragEvent.relatedTarget = dropState.cur.element\n  }\n  if (dragEvent.type === 'dragmove' && dropState.cur.dropzone) {\n    dropEvents.move = new DropEvent(dropState, dragEvent, 'dropmove')\n\n    dropEvents.move.dragmove = dragEvent\n    dragEvent.dropzone = dropState.cur.dropzone\n  }\n\n  return dropEvents\n}\n\nfunction fireDropEvents (interaction: Interact.Interaction, events) {\n  const { dropState } = interaction\n  const {\n    activeDrops,\n    cur,\n    prev,\n  } = dropState\n\n  if (events.leave) { prev.dropzone.fire(events.leave) }\n  if (events.move) { cur.dropzone.fire(events.move) }\n  if (events.enter) { cur.dropzone.fire(events.enter) }\n  if (events.drop) { cur.dropzone.fire(events.drop) }\n\n  if (events.deactivate) {\n    fireActivationEvents(activeDrops, events.deactivate)\n  }\n\n  dropState.prev.dropzone  = cur.dropzone\n  dropState.prev.element = cur.element\n}\n\nfunction onEventCreated ({ interaction, iEvent, event }: Interact.DoPhaseArg<'drag', Interact.EventPhase>, scope) {\n  if (iEvent.type !== 'dragmove' && iEvent.type !== 'dragend') { return }\n\n  const { dropState } = interaction\n\n  if (scope.dynamicDrop) {\n    dropState.activeDrops = getActiveDrops(scope, interaction.element)\n  }\n\n  const dragEvent = iEvent\n  const dropResult = getDrop(interaction, dragEvent, event)\n\n  // update rejected status\n  dropState.rejected = dropState.rejected &&\n    !!dropResult &&\n    dropResult.dropzone === dropState.cur.dropzone &&\n    dropResult.element === dropState.cur.element\n\n  dropState.cur.dropzone  = dropResult && dropResult.dropzone\n  dropState.cur.element = dropResult && dropResult.element\n\n  dropState.events = getDropEvents(interaction, event, dragEvent)\n}\n\nfunction dropzoneMethod (interactable: Interact.Interactable): Interact.DropzoneOptions\nfunction dropzoneMethod (interactable: Interact.Interactable, options: Interact.DropzoneOptions | boolean)\nfunction dropzoneMethod (interactable: Interact.Interactable, options?: Interact.DropzoneOptions | boolean) {\n  if (utils.is.object(options)) {\n    interactable.options.drop.enabled = options.enabled !== false\n\n    if (options.listeners) {\n      const normalized = utils.normalizeListeners(options.listeners)\n      // rename 'drop' to '' as it will be prefixed with 'drop'\n      const corrected = Object.keys(normalized).reduce((acc, type) => {\n        const correctedType = /^(enter|leave)/.test(type)\n          ? `drag${type}`\n          : /^(activate|deactivate|move)/.test(type)\n            ? `drop${type}`\n            : type\n\n        acc[correctedType] = normalized[type]\n\n        return acc\n      }, {})\n\n      interactable.off(interactable.options.drop.listeners)\n      interactable.on(corrected)\n      interactable.options.drop.listeners = corrected\n    }\n\n    if (utils.is.func(options.ondrop)) { interactable.on('drop', options.ondrop) }\n    if (utils.is.func(options.ondropactivate)) { interactable.on('dropactivate', options.ondropactivate) }\n    if (utils.is.func(options.ondropdeactivate)) { interactable.on('dropdeactivate', options.ondropdeactivate) }\n    if (utils.is.func(options.ondragenter)) { interactable.on('dragenter', options.ondragenter) }\n    if (utils.is.func(options.ondragleave)) { interactable.on('dragleave', options.ondragleave) }\n    if (utils.is.func(options.ondropmove)) { interactable.on('dropmove', options.ondropmove) }\n\n    if (/^(pointer|center)$/.test(options.overlap as string)) {\n      interactable.options.drop.overlap = options.overlap\n    }\n    else if (utils.is.number(options.overlap)) {\n      interactable.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0)\n    }\n    if ('accept' in options) {\n      interactable.options.drop.accept = options.accept\n    }\n    if ('checker' in options) {\n      interactable.options.drop.checker = options.checker\n    }\n\n    return interactable\n  }\n\n  if (utils.is.bool(options)) {\n    interactable.options.drop.enabled = options\n\n    return interactable\n  }\n\n  return interactable.options.drop\n}\n\nfunction dropCheckMethod (\n  interactable: Interact.Interactable,\n  dragEvent: InteractEvent,\n  event: Interact.PointerEventType,\n  draggable: Interact.Interactable,\n  draggableElement: Interact.Element,\n  dropElement: Interact.Element,\n  rect: any,\n) {\n  let dropped = false\n\n  // if the dropzone has no rect (eg. display: none)\n  // call the custom dropChecker or just return false\n  if (!(rect = rect || interactable.getRect(dropElement))) {\n    return (interactable.options.drop.checker\n      ? interactable.options.drop.checker(dragEvent, event, dropped, interactable, dropElement, draggable, draggableElement)\n      : false)\n  }\n\n  const dropOverlap = interactable.options.drop.overlap\n\n  if (dropOverlap === 'pointer') {\n    const origin = utils.getOriginXY(draggable, draggableElement, 'drag')\n    const page = utils.pointer.getPageXY(dragEvent)\n\n    page.x += origin.x\n    page.y += origin.y\n\n    const horizontal = (page.x > rect.left) && (page.x < rect.right)\n    const vertical   = (page.y > rect.top) && (page.y < rect.bottom)\n\n    dropped = horizontal && vertical\n  }\n\n  const dragRect = draggable.getRect(draggableElement)\n\n  if (dragRect && dropOverlap === 'center') {\n    const cx = dragRect.left + dragRect.width  / 2\n    const cy = dragRect.top  + dragRect.height / 2\n\n    dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom\n  }\n\n  if (dragRect && utils.is.number(dropOverlap)) {\n    const overlapArea  = (Math.max(0, Math.min(rect.right, dragRect.right) - Math.max(rect.left, dragRect.left)) *\n                          Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top, dragRect.top)))\n\n    const overlapRatio = overlapArea / (dragRect.width * dragRect.height)\n\n    dropped = overlapRatio >= dropOverlap\n  }\n\n  if (interactable.options.drop.checker) {\n    dropped = interactable.options.drop.checker(dragEvent, event, dropped, interactable, dropElement, draggable, draggableElement)\n  }\n\n  return dropped\n}\n\nconst drop: Interact.Plugin = {\n  id: 'actions/drop',\n  install,\n  listeners: {\n    'interactions:before-action-start': ({ interaction }) => {\n      if (interaction.prepared.name !== 'drag') { return }\n\n      interaction.dropState = {\n        cur: {\n          dropzone: null,\n          element: null,\n        },\n        prev: {\n          dropzone: null,\n          element: null,\n        },\n        rejected: null,\n        events: null,\n        activeDrops: [],\n      }\n    },\n\n    'interactions:after-action-start': ({ interaction, event, iEvent: dragEvent }: Interact.DoPhaseArg<'drag', Interact.EventPhase>, scope) => {\n      if (interaction.prepared.name !== 'drag') { return }\n\n      const { dropState } = interaction\n\n      // reset active dropzones\n      dropState.activeDrops = null\n      dropState.events = null\n      dropState.activeDrops = getActiveDrops(scope, interaction.element)\n      dropState.events = getDropEvents(interaction, event, dragEvent)\n\n      if (dropState.events.activate) {\n        fireActivationEvents(dropState.activeDrops, dropState.events.activate)\n        scope.fire('actions/drop:start', { interaction, dragEvent })\n      }\n    },\n\n    // FIXME proper signal types\n    'interactions:action-move': onEventCreated,\n    'interactions:action-end': onEventCreated,\n\n    'interactions:after-action-move': function fireDropAfterMove ({ interaction, iEvent: dragEvent }: Interact.DoPhaseArg<'drag', Interact.EventPhase>, scope) {\n      if (interaction.prepared.name !== 'drag') { return }\n\n      fireDropEvents(interaction, interaction.dropState.events)\n\n      scope.fire('actions/drop:move', { interaction, dragEvent })\n      interaction.dropState.events = {}\n    },\n\n    'interactions:after-action-end': ({ interaction, iEvent: dragEvent }: Interact.DoPhaseArg<'drag', Interact.EventPhase>, scope) => {\n      if (interaction.prepared.name !== 'drag') { return }\n\n      fireDropEvents(interaction, interaction.dropState.events)\n      scope.fire('actions/drop:end', { interaction, dragEvent })\n    },\n\n    'interactions:stop': ({ interaction }) => {\n      if (interaction.prepared.name !== 'drag') { return }\n\n      const { dropState } = interaction\n\n      if (dropState) {\n        dropState.activeDrops = null\n        dropState.events = null\n        dropState.cur.dropzone = null\n        dropState.cur.element = null\n        dropState.prev.dropzone = null\n        dropState.prev.element = null\n        dropState.rejected = false\n      }\n    },\n  },\n  getActiveDrops,\n  getDrop,\n  getDropEvents,\n  fireDropEvents,\n  defaults: {\n    enabled: false,\n    accept : null,\n    overlap: 'pointer',\n  } as Interact.DropzoneOptions,\n}\n\nexport default drop\n"
	]
}