{
	"version": 3,
	"sources": [
		"gesture.ts"
	],
	"names": [
		"utils",
		"updateGestureProps",
		"interaction",
		"iEvent",
		"phase",
		"prepared",
		"name",
		"pointers",
		"map",
		"p",
		"pointer",
		"starting",
		"ending",
		"deltaSource",
		"interactable",
		"options",
		"touches",
		"distance",
		"touchDistance",
		"box",
		"touchBBox",
		"scale",
		"ds",
		"angle",
		"touchAngle",
		"da",
		"gesture",
		"startDistance",
		"startAngle",
		"prevEvent",
		"is",
		"number",
		"Infinity",
		"isNaN",
		"id",
		"before",
		"install",
		"scope",
		"actions",
		"Interactable",
		"defaults",
		"prototype",
		"gesturable",
		"object",
		"this",
		"enabled",
		"setPerAction",
		"setOnEvents",
		"bool",
		"methodDict",
		"listeners",
		"interactions:action-start",
		"interactions:action-move",
		"interactions:action-end",
		"[object Object]",
		"arg",
		"length",
		"gestureOptions",
		"action",
		"getCursor"
	],
	"mappings": "UAAYA,MAAW,wBAuGvB,SAASC,GAAoBC,YAAEA,EAAFC,OAAeA,EAAfC,MAAuBA,IAClD,GAAkC,YAA9BF,EAAYG,SAASC,KAAsB,OAE/C,MAAMC,EAAWL,EAAYK,SAASC,IAAIC,GAAKA,EAAEC,SAC3CC,EAAqB,UAAVP,EACXQ,EAAmB,QAAVR,EACTS,EAAcX,EAAYY,aAAaC,QAAQF,YAIrD,GAFAV,EAAOa,QAAU,CAACT,EAAS,GAAIA,EAAS,IAEpCI,EACFR,EAAOc,SAAWjB,EAAMU,QAAQQ,cAAcX,EAAUM,GACxDV,EAAOgB,IAAWnB,EAAMU,QAAQU,UAAUb,GAC1CJ,EAAOkB,MAAW,EAClBlB,EAAOmB,GAAW,EAClBnB,EAAOoB,MAAWvB,EAAMU,QAAQc,WAAWjB,EAAUM,GACrDV,EAAOsB,GAAW,EAElBvB,EAAYwB,QAAQC,cAAgBxB,EAAOc,SAC3Cf,EAAYwB,QAAQE,WAAazB,EAAOoB,WAErC,GAAIX,EAAQ,CACf,MAAMiB,EAAY3B,EAAY2B,UAE9B1B,EAAOc,SAAWY,EAAUZ,SAC5Bd,EAAOgB,IAAWU,EAAUV,IAC5BhB,EAAOkB,MAAWQ,EAAUR,MAC5BlB,EAAOmB,GAAW,EAClBnB,EAAOoB,MAAWM,EAAUN,MAC5BpB,EAAOsB,GAAW,OAGlBtB,EAAOc,SAAWjB,EAAMU,QAAQQ,cAAcX,EAAUM,GACxDV,EAAOgB,IAAWnB,EAAMU,QAAQU,UAAUb,GAC1CJ,EAAOkB,MAAWlB,EAAOc,SAAWf,EAAYwB,QAAQC,cACxDxB,EAAOoB,MAAWvB,EAAMU,QAAQc,WAAWjB,EAAUM,GAErDV,EAAOmB,GAAKnB,EAAOkB,MAAQnB,EAAYwB,QAAQL,MAC/ClB,EAAOsB,GAAKtB,EAAOoB,MAAQrB,EAAYwB,QAAQH,MAGjDrB,EAAYwB,QAAQT,SAAWd,EAAOc,SACtCf,EAAYwB,QAAQH,MAAQpB,EAAOoB,MAE/BvB,EAAM8B,GAAGC,OAAO5B,EAAOkB,QACvBlB,EAAOkB,QAAUW,EAAAA,IAChBC,MAAM9B,EAAOkB,SAChBnB,EAAYwB,QAAQL,MAAQlB,EAAOkB,OAIvC,MAAMK,EAA2B,CAC/BQ,GAAI,kBACJC,OAAQ,CAAC,eAAgB,kBACzBC,QA5GgBC,GAChB,MAAMC,QACJA,EADIC,aAEJA,EAFIC,SAGJA,GACEH,EAyBJE,EAAaE,UAAUC,WAAa,SAAuC3B,GACzE,OAAIf,EAAM8B,GAAGa,OAAO5B,IAClB6B,KAAK7B,QAAQW,QAAQmB,SAA8B,IAApB9B,EAAQ8B,QACvCD,KAAKE,aAAa,UAAW/B,GAC7B6B,KAAKG,YAAY,UAAWhC,GAErB6B,MAGL5C,EAAM8B,GAAGkB,KAAKjC,IAChB6B,KAAK7B,QAAQW,QAAQmB,QAAU9B,EAExB6B,MAGFA,KAAK7B,QAAQW,SAGtBY,EAAQ9B,IAAIkB,QAAUA,EACtBY,EAAQW,WAAWvB,QAAU,aAE7Bc,EAASF,QAAQZ,QAAUA,EAAQc,UA0DnCU,UAAW,CACTC,4BAA6BlD,EAC7BmD,2BAA4BnD,EAC5BoD,0BAA2BpD,EAE3BqD,oBAAuBpD,YAAAA,IACrBA,EAAYwB,QAAU,CACpBH,MAAO,EACPN,SAAU,EACVI,MAAO,EACPO,WAAY,EACZD,cAAe,IAInB2B,mBAAoBC,GAClB,GAAIA,EAAIrD,YAAYK,SAASiD,OAAS,EACpC,OAGF,MAAMC,EAAiBF,EAAIzC,aAAaC,QAAQW,QAEhD,OAAM+B,GAAkBA,EAAeZ,SAIvCU,EAAIG,OAAS,CAAEpD,KAAM,YAEd,QANP,IAUJkC,SAAU,GAGVmB,UAAS,IACA,mBAIIjC",
	"sourcesContent": [
		"import * as utils from '@interactjs/utils/index'\n\nexport type GesturableMethod = Interact.ActionMethod<Interact.GesturableOptions>\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    gesture?: {\n      angle: number           // angle from first to second touch\n      distance: number\n      scale: number           // gesture.distance / gesture.startDistance\n      startAngle: number      // angle of line joining two touches\n      startDistance: number   // distance between two touches of touchStart\n    }\n  }\n}\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    gesturable: GesturableMethod\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface ActionDefaults {\n    gesture: Interact.GesturableOptions\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface ActionMap {\n    gesture?: typeof gesture\n  }\n}\n\nexport interface GestureEvent extends Interact.InteractEvent<'gesture'> {\n  distance: number\n  angle: number\n  da: number // angle change\n  scale: number // ratio of distance start to current event\n  ds: number // scale change\n  box: Interact.Rect // enclosing box of all points\n  touches: Interact.PointerType[]\n}\n\nexport interface GestureSignalArg extends Interact.DoPhaseArg<'gesture', Interact.EventPhase> {\n  iEvent: GestureEvent\n  interaction: Interact.Interaction<'gesture'>\n}\n\nfunction install (scope: Interact.Scope) {\n  const {\n    actions,\n    Interactable,\n    defaults,\n  } = scope\n\n  /**\n   * ```js\n   * interact(element).gesturable({\n   *     onstart: function (event) {},\n   *     onmove : function (event) {},\n   *     onend  : function (event) {},\n   *\n   *     // limit multiple gestures.\n   *     // See the explanation in {@link Interactable.draggable} example\n   *     max: Infinity,\n   *     maxPerElement: 1,\n   * })\n   *\n   * var isGestureable = interact(element).gesturable()\n   * ```\n   *\n   * Gets or sets whether multitouch gestures can be performed on the target\n   *\n   * @param {boolean | object} [options] true/false or An object with event\n   * listeners to be fired on gesture events (makes the Interactable gesturable)\n   * @return {boolean | Interactable} A boolean indicating if this can be the\n   * target of gesture events, or this Interactable\n   */\n  Interactable.prototype.gesturable = function (this: Interact.Interactable, options: Interact.GesturableOptions | boolean) {\n    if (utils.is.object(options)) {\n      this.options.gesture.enabled = options.enabled !== false\n      this.setPerAction('gesture', options)\n      this.setOnEvents('gesture', options)\n\n      return this\n    }\n\n    if (utils.is.bool(options)) {\n      this.options.gesture.enabled = options\n\n      return this\n    }\n\n    return this.options.gesture as Interact.Options\n  } as GesturableMethod\n\n  actions.map.gesture = gesture\n  actions.methodDict.gesture = 'gesturable'\n\n  defaults.actions.gesture = gesture.defaults\n}\n\nfunction updateGestureProps ({ interaction, iEvent, phase }: GestureSignalArg) {\n  if (interaction.prepared.name !== 'gesture') { return }\n\n  const pointers = interaction.pointers.map(p => p.pointer)\n  const starting = phase === 'start'\n  const ending = phase === 'end'\n  const deltaSource = interaction.interactable.options.deltaSource\n\n  iEvent.touches = [pointers[0], pointers[1]]\n\n  if (starting) {\n    iEvent.distance = utils.pointer.touchDistance(pointers, deltaSource)\n    iEvent.box      = utils.pointer.touchBBox(pointers)\n    iEvent.scale    = 1\n    iEvent.ds       = 0\n    iEvent.angle    = utils.pointer.touchAngle(pointers, deltaSource)\n    iEvent.da       = 0\n\n    interaction.gesture.startDistance = iEvent.distance\n    interaction.gesture.startAngle = iEvent.angle\n  }\n  else if (ending) {\n    const prevEvent = interaction.prevEvent as GestureEvent\n\n    iEvent.distance = prevEvent.distance\n    iEvent.box      = prevEvent.box\n    iEvent.scale    = prevEvent.scale\n    iEvent.ds       = 0\n    iEvent.angle    = prevEvent.angle\n    iEvent.da       = 0\n  }\n  else {\n    iEvent.distance = utils.pointer.touchDistance(pointers, deltaSource)\n    iEvent.box      = utils.pointer.touchBBox(pointers)\n    iEvent.scale    = iEvent.distance / interaction.gesture.startDistance\n    iEvent.angle    = utils.pointer.touchAngle(pointers, deltaSource)\n\n    iEvent.ds = iEvent.scale - interaction.gesture.scale\n    iEvent.da = iEvent.angle - interaction.gesture.angle\n  }\n\n  interaction.gesture.distance = iEvent.distance\n  interaction.gesture.angle = iEvent.angle\n\n  if (utils.is.number(iEvent.scale) &&\n      iEvent.scale !== Infinity &&\n      !isNaN(iEvent.scale)) {\n    interaction.gesture.scale = iEvent.scale\n  }\n}\n\nconst gesture: Interact.Plugin = {\n  id: 'actions/gesture',\n  before: ['actions/drag', 'actions/resize'],\n  install,\n  listeners: {\n    'interactions:action-start': updateGestureProps,\n    'interactions:action-move': updateGestureProps,\n    'interactions:action-end': updateGestureProps,\n\n    'interactions:new': ({ interaction }) => {\n      interaction.gesture = {\n        angle: 0,\n        distance: 0,\n        scale: 1,\n        startAngle: 0,\n        startDistance: 0,\n      }\n    },\n\n    'auto-start:check': arg => {\n      if (arg.interaction.pointers.length < 2) {\n        return undefined\n      }\n\n      const gestureOptions = arg.interactable.options.gesture\n\n      if (!(gestureOptions && gestureOptions.enabled)) {\n        return undefined\n      }\n\n      arg.action = { name: 'gesture' }\n\n      return false\n    },\n  },\n\n  defaults: {\n  },\n\n  getCursor () {\n    return ''\n  },\n}\n\nexport default gesture\n"
	]
}