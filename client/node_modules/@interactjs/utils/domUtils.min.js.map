{
	"version": 3,
	"sources": [
		"domUtils.ts"
	],
	"names": [
		"browser",
		"domObjects",
		"is",
		"win",
		"getWindow",
		"nodeContains",
		"parent",
		"child",
		"parentNode",
		"closest",
		"element",
		"selector",
		"matchesSelector",
		"node",
		"docFrag",
		"host",
		"window",
		"realWindow",
		"replace",
		"prefixedMatchesSelector",
		"getParent",
		"el",
		"indexOfDeepestElement",
		"elements",
		"i",
		"n",
		"deepestZoneParents",
		"deepestZone",
		"index",
		"length",
		"dropzone",
		"ownerDocument",
		"deepestZIndex",
		"parseInt",
		"getComputedStyle",
		"zIndex",
		"parentParent",
		"unshift",
		"HTMLElement",
		"SVGElement",
		"SVGSVGElement",
		"ownerSVGElement",
		"dropzoneParents",
		"parents",
		"lastChild",
		"previousSibling",
		"matchesUpTo",
		"limit",
		"getActualElement",
		"SVGElementInstance",
		"correspondingUseElement",
		"getScrollXY",
		"relevantWindow",
		"x",
		"scrollX",
		"document",
		"documentElement",
		"scrollLeft",
		"y",
		"scrollY",
		"scrollTop",
		"getElementClientRect",
		"clientRect",
		"getBoundingClientRect",
		"getClientRects",
		"left",
		"right",
		"top",
		"bottom",
		"width",
		"height",
		"getElementRect",
		"isIOS7",
		"scroll",
		"getPath",
		"path",
		"push",
		"trySelector",
		"value",
		"string",
		"querySelector"
	],
	"mappings": "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",
	"sourcesContent": [
		"import browser from './browser'\nimport domObjects from './domObjects'\nimport * as is from './is'\nimport win, { getWindow } from './window'\n\nexport function nodeContains (parent: Node | Interact.EventTarget, child: Node | Interact.EventTarget) {\n  while (child) {\n    if (child === parent) {\n      return true\n    }\n\n    child = (child as Node).parentNode\n  }\n\n  return false\n}\n\nexport function closest (element: Node, selector: string) {\n  while (is.element(element)) {\n    if (matchesSelector(element, selector)) { return element }\n\n    element = parentNode(element)\n  }\n\n  return null\n}\n\nexport function parentNode (node: Node | Document) {\n  let parent = node.parentNode\n\n  if (is.docFrag(parent)) {\n    // skip past #shado-root fragments\n    // tslint:disable-next-line\n    while ((parent = (parent as any).host) && is.docFrag(parent)) {\n      continue\n    }\n\n    return parent\n  }\n\n  return parent\n}\n\nexport function matchesSelector (element: Interact.Element, selector: string) {\n  // remove /deep/ from selectors if shadowDOM polyfill is used\n  if (win.window !== win.realWindow) {\n    selector = selector.replace(/\\/deep\\//g, ' ')\n  }\n\n  return element[browser.prefixedMatchesSelector](selector)\n}\n\nconst getParent = el => el.parentNode ? el.parentNode : el.host\n\n// Test for the element that's \"above\" all other qualifiers\nexport function indexOfDeepestElement (elements: Interact.Element[] | NodeListOf<Element>) {\n  let deepestZoneParents = []\n  let deepestZone = elements[0]\n  let index = deepestZone ? 0 : -1\n  let i\n  let n\n\n  for (i = 1; i < elements.length; i++) {\n    const dropzone = elements[i]\n\n    // an element might belong to multiple selector dropzones\n    if (!dropzone || dropzone === deepestZone) {\n      continue\n    }\n\n    if (!deepestZone) {\n      deepestZone = dropzone\n      index = i\n      continue\n    }\n\n    // check if the deepest or current are document.documentElement or document.rootElement\n    // - if the current dropzone is, do nothing and continue\n    if (dropzone.parentNode === dropzone.ownerDocument) {\n      continue\n    }\n    // - if deepest is, update with the current dropzone and continue to next\n    else if (deepestZone.parentNode === dropzone.ownerDocument) {\n      deepestZone = dropzone\n      index = i\n      continue\n    }\n\n    // compare zIndex of siblings\n    if (dropzone.parentNode === deepestZone.parentNode) {\n      const deepestZIndex = parseInt(getWindow(deepestZone).getComputedStyle(deepestZone).zIndex, 10) || 0\n      const dropzoneZIndex = parseInt(getWindow(dropzone).getComputedStyle(dropzone).zIndex, 10) || 0\n\n      if (dropzoneZIndex >= deepestZIndex) {\n        deepestZone = dropzone\n        index = i\n      }\n\n      continue\n    }\n\n    // populate the ancestry array for the latest deepest dropzone\n    if (!deepestZoneParents.length) {\n      let parent = deepestZone\n      let parentParent\n\n      while ((parentParent = getParent(parent)) && parentParent !== parent.ownerDocument) {\n        deepestZoneParents.unshift(parent)\n        parent = parentParent\n      }\n    }\n\n    let parent\n\n    // if this element is an svg element and the current deepest is an\n    // HTMLElement\n    if (deepestZone instanceof domObjects.HTMLElement &&\n        dropzone instanceof domObjects.SVGElement &&\n        !(dropzone instanceof domObjects.SVGSVGElement)) {\n      if (dropzone === deepestZone.parentNode) {\n        continue\n      }\n\n      parent = dropzone.ownerSVGElement\n    }\n    else {\n      parent = dropzone\n    }\n\n    const dropzoneParents = []\n\n    while (parent.parentNode !== parent.ownerDocument) {\n      dropzoneParents.unshift(parent)\n      parent = getParent(parent)\n    }\n\n    n = 0\n\n    // get (position of last common ancestor) + 1\n    while (dropzoneParents[n] && dropzoneParents[n] === deepestZoneParents[n]) {\n      n++\n    }\n\n    const parents = [\n      dropzoneParents[n - 1],\n      dropzoneParents[n],\n      deepestZoneParents[n],\n    ]\n\n    let child = parents[0].lastChild\n\n    while (child) {\n      if (child === parents[1]) {\n        deepestZone = dropzone\n        index = i\n        deepestZoneParents = dropzoneParents\n\n        break\n      }\n      else if (child === parents[2]) {\n        break\n      }\n\n      child = child.previousSibling\n    }\n  }\n\n  return index\n}\n\nexport function matchesUpTo (element: Interact.Element, selector: string, limit: Node) {\n  while (is.element(element)) {\n    if (matchesSelector(element, selector)) {\n      return true\n    }\n\n    element = parentNode(element) as Interact.Element\n\n    if (element === limit) {\n      return matchesSelector(element, selector)\n    }\n  }\n\n  return false\n}\n\nexport function getActualElement (element: Interact.Element) {\n  return (element instanceof domObjects.SVGElementInstance\n    ? (element as SVGElement).correspondingUseElement\n    : element)\n}\n\nexport function getScrollXY (relevantWindow) {\n  relevantWindow = relevantWindow || win.window\n  return {\n    x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,\n    y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop,\n  }\n}\n\nexport function getElementClientRect (element: Interact.Element) {\n  const clientRect = (element instanceof domObjects.SVGElement\n    ? element.getBoundingClientRect()\n    : element.getClientRects()[0])\n\n  return clientRect && {\n    left  : clientRect.left,\n    right : clientRect.right,\n    top   : clientRect.top,\n    bottom: clientRect.bottom,\n    width : clientRect.width  || clientRect.right  - clientRect.left,\n    height: clientRect.height || clientRect.bottom - clientRect.top,\n  }\n}\n\nexport function getElementRect (element: Interact.Element) {\n  const clientRect = getElementClientRect(element)\n\n  if (!browser.isIOS7 && clientRect) {\n    const scroll = getScrollXY(win.getWindow(element))\n\n    clientRect.left   += scroll.x\n    clientRect.right  += scroll.x\n    clientRect.top    += scroll.y\n    clientRect.bottom += scroll.y\n  }\n\n  return clientRect\n}\n\nexport function getPath (node: Node | Document) {\n  const path = []\n\n  while (node) {\n    path.push(node)\n    node = parentNode(node)\n  }\n\n  return path\n}\n\nexport function trySelector (value) {\n  if (!is.string(value)) { return false }\n\n  // an exception will be raised if it is invalid\n  domObjects.document.querySelector(value)\n  return true\n}\n"
	]
}