{
	"version": 3,
	"sources": [
		"InteractableMethods.ts"
	],
	"names": [
		"warnOnce",
		"is",
		"styleCursor",
		"newValue",
		"bool",
		"this",
		"options",
		"actionChecker",
		"checker",
		"func",
		"id",
		"install",
		"scope",
		"Interactable",
		"prototype",
		"getAction",
		"pointer",
		"event",
		"interaction",
		"element",
		"action",
		"interactable",
		"rect",
		"getRect",
		"buttons",
		"0",
		"1",
		"3",
		"4",
		"button",
		"arg",
		"fire",
		"defaultActionChecker",
		"ignoreFrom",
		"_backCompatOption",
		"allowFrom"
	],
	"mappings": "mBAASA,MAAgB,kCACbC,MAAQ,qBAkLpB,SAASC,EAA0CC,GACjD,OAAIF,EAAGG,KAAKD,IACVE,KAAKC,QAAQJ,YAAcC,EAEpBE,MAGQ,OAAbF,UACKE,KAAKC,QAAQJ,YAEbG,MAGFA,KAAKC,QAAQJ,YAGtB,SAASK,EAA4CC,GACnD,OAAIP,EAAGQ,KAAKD,IACVH,KAAKC,QAAQC,cAAgBC,EAEtBH,MAGO,OAAZG,UACKH,KAAKC,QAAQC,cAEbF,MAGFA,KAAKC,QAAQC,4BAGP,CACbG,GAAI,iCACJC,QA5LgBC,GAChB,MAAMC,aAEJA,GACED,EAEJC,EAAaC,UAAUC,UAAY,SAEjCC,EACAC,EACAC,EACAC,GAEA,MAAMC,EA+GV,SACEC,EACAJ,EACAC,EACAC,EACAP,GAEA,MAAMU,EAAOD,EAAaE,QAAQJ,GAC5BK,EAAWP,EAAqBO,SAAY,CAChDC,EAAG,EACHC,EAAG,EACHC,EAAG,EACHC,EAAG,IACDX,EAAqBY,QACnBC,EAAM,CACVV,OAAQ,KACRC,aAAAA,EACAH,YAAAA,EACAC,QAAAA,EACAG,KAAAA,EACAE,QAAAA,GAKF,OAFAZ,EAAMmB,KAAK,mBAAoBD,GAExBA,EAAIV,OAxIMY,CAAqB3B,KAAMY,EAAOC,EAAaC,EAASP,GAEvE,OAAIP,KAAKC,QAAQC,cACRF,KAAKC,QAAQC,cAAcS,EAASC,EAAOG,EAAQf,KAAMc,EAASD,GAGpEE,GA+BTP,EAAaC,UAAUmB,WAAajC,GAAS,SAAuCG,GAClF,OAAOE,KAAK6B,kBAAkB,aAAc/B,KAC3C,qGAyBHU,EAAaC,UAAUqB,UAAYnC,GAAS,SAAuCG,GACjF,OAAOE,KAAK6B,kBAAkB,YAAa/B,KAC1C,mGAiCHU,EAAaC,UAAUP,cAAgBA,EASvCM,EAAaC,UAAUZ,YAAcA",
	"sourcesContent": [
		"import { warnOnce } from '@interactjs/utils/index'\nimport * as is from '@interactjs/utils/is'\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    getAction: (\n      this: Interact.Interactable,\n      pointer: Interact.PointerType,\n      event: Interact.PointerEventType,\n      interaction: Interact.Interaction,\n      element: Interact.Element,\n    ) => Interact.ActionProps | null\n    styleCursor: typeof styleCursor\n    actionChecker: typeof actionChecker\n    ignoreFrom: {\n      (...args: any[]): Interactable\n      (): boolean\n    }\n    allowFrom: {\n      (...args: any[]): Interactable\n      (): boolean\n    }\n  }\n}\n\nfunction install (scope: Interact.Scope) {\n  const {\n    /** @lends Interactable */\n    Interactable, // tslint:disable-line no-shadowed-variable\n  } = scope\n\n  Interactable.prototype.getAction = function getAction (\n    this: Interact.Interactable,\n    pointer: Interact.PointerType,\n    event: Interact.PointerEventType,\n    interaction: Interact.Interaction,\n    element: Interact.Element,\n  ): Interact.ActionProps {\n    const action = defaultActionChecker(this, event, interaction, element, scope)\n\n    if (this.options.actionChecker) {\n      return this.options.actionChecker(pointer, event, action, this, element, interaction)\n    }\n\n    return action\n  }\n\n  /**\n   * ```js\n   * interact(element, { ignoreFrom: document.getElementById('no-action') })\n   * // or\n   * interact(element).ignoreFrom('input, textarea, a')\n   * ```\n   * @deprecated\n   * If the target of the `mousedown`, `pointerdown` or `touchstart` event or any\n   * of it's parents match the given CSS selector or Element, no\n   * drag/resize/gesture is started.\n   *\n   * Don't use this method. Instead set the `ignoreFrom` option for each action\n   * or for `pointerEvents`\n   *\n   * @example\n   * interact(targett)\n   *   .draggable({\n   *     ignoreFrom: 'input, textarea, a[href]'',\n   *   })\n   *   .pointerEvents({\n   *     ignoreFrom: '[no-pointer]',\n   *   })\n   *\n   * @param {string | Element | null} [newValue] a CSS selector string, an\n   * Element or `null` to not ignore any elements\n   * @return {string | Element | object} The current ignoreFrom value or this\n   * Interactable\n   */\n  Interactable.prototype.ignoreFrom = warnOnce(function (this: Interact.Interactable, newValue) {\n    return this._backCompatOption('ignoreFrom', newValue)\n  }, 'Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue}).')\n\n  /**\n   * @deprecated\n   *\n   * A drag/resize/gesture is started only If the target of the `mousedown`,\n   * `pointerdown` or `touchstart` event or any of it's parents match the given\n   * CSS selector or Element.\n   *\n   * Don't use this method. Instead set the `allowFrom` option for each action\n   * or for `pointerEvents`\n   *\n   * @example\n   * interact(targett)\n   *   .resizable({\n   *     allowFrom: '.resize-handle',\n   *   .pointerEvents({\n   *     allowFrom: '.handle',,\n   *   })\n   *\n   * @param {string | Element | null} [newValue] a CSS selector string, an\n   * Element or `null` to allow from any element\n   * @return {string | Element | object} The current allowFrom value or this\n   * Interactable\n   */\n  Interactable.prototype.allowFrom = warnOnce(function (this: Interact.Interactable, newValue) {\n    return this._backCompatOption('allowFrom', newValue)\n  }, 'Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue}).')\n\n  /**\n   * ```js\n   * interact('.resize-drag')\n   *   .resizable(true)\n   *   .draggable(true)\n   *   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n   *\n   *   if (interact.matchesSelector(event.target, '.drag-handle')) {\n   *     // force drag with handle target\n   *     action.name = drag\n   *   }\n   *   else {\n   *     // resize from the top and right edges\n   *     action.name  = 'resize'\n   *     action.edges = { top: true, right: true }\n   *   }\n   *\n   *   return action\n   * })\n   * ```\n   *\n   * Returns or sets the function used to check action to be performed on\n   * pointerDown\n   *\n   * @param {function | null} [checker] A function which takes a pointer event,\n   * defaultAction string, interactable, element and interaction as parameters\n   * and returns an object with name property 'drag' 'resize' or 'gesture' and\n   * optionally an `edges` object with boolean 'top', 'left', 'bottom' and right\n   * props.\n   * @return {Function | Interactable} The checker function or this Interactable\n   */\n  Interactable.prototype.actionChecker = actionChecker\n\n  /**\n   * Returns or sets whether the the cursor should be changed depending on the\n   * action that would be performed if the mouse were pressed and dragged.\n   *\n   * @param {boolean} [newValue]\n   * @return {boolean | Interactable} The current setting or this Interactable\n   */\n  Interactable.prototype.styleCursor = styleCursor\n}\n\nfunction defaultActionChecker (\n  interactable: Interact.Interactable,\n  event: Interact.PointerEventType,\n  interaction: Interact.Interaction,\n  element: Interact.Element,\n  scope: Interact.Scope,\n) {\n  const rect = interactable.getRect(element)\n  const buttons = (event as MouseEvent).buttons || ({\n    0: 1,\n    1: 4,\n    3: 8,\n    4: 16,\n  })[(event as MouseEvent).button as 0 | 1 | 3 | 4]\n  const arg = {\n    action: null,\n    interactable,\n    interaction,\n    element,\n    rect,\n    buttons,\n  }\n\n  scope.fire('auto-start:check', arg)\n\n  return arg.action\n}\n\nfunction styleCursor (this: Interact.Interactable): boolean\nfunction styleCursor (this: Interact.Interactable, newValue: boolean): typeof this\nfunction styleCursor (this: Interact.Interactable, newValue?: boolean) {\n  if (is.bool(newValue)) {\n    this.options.styleCursor = newValue\n\n    return this\n  }\n\n  if (newValue === null) {\n    delete this.options.styleCursor\n\n    return this\n  }\n\n  return this.options.styleCursor\n}\n\nfunction actionChecker (this: Interact.Interactable, checker: any) {\n  if (is.func(checker)) {\n    this.options.actionChecker = checker\n\n    return this\n  }\n\n  if (checker === null) {\n    delete this.options.actionChecker\n\n    return this\n  }\n\n  return this.options.actionChecker\n}\n\nexport default {\n  id: 'auto-start/interactableMethods',\n  install,\n}\n"
	]
}