{
	"version": 3,
	"sources": [
		"index.ts"
	],
	"names": [
		"domUtils",
		"is",
		"raf",
		"getStringOptionResult",
		"getWindow",
		"autoScroll",
		"defaults",
		"enabled",
		"margin",
		"container",
		"speed",
		"now",
		"Date",
		"interaction",
		"i",
		"x",
		"y",
		"isScrolling",
		"prevTime",
		"start",
		"cancel",
		"request",
		"scroll",
		"stop",
		"interactable",
		"element",
		"actionName",
		"prepared",
		"name",
		"options",
		"getContainer",
		"dt",
		"s",
		"scrollBy",
		"prevScroll",
		"getScroll",
		"window",
		"scrollLeft",
		"scrollTop",
		"curScroll",
		"delta",
		"fire",
		"type",
		"target",
		"check",
		"onInteractionMove",
		"pointer",
		"interacting",
		"simulation",
		"top",
		"right",
		"bottom",
		"left",
		"clientX",
		"clientY",
		"innerWidth",
		"innerHeight",
		"rect",
		"getElementClientRect",
		"value",
		"string",
		"document",
		"body",
		"getScrollSize",
		"scrollWidth",
		"scrollHeight",
		"getScrollSizeDelta",
		"func",
		"scrollOptions",
		"scrollContainer",
		"prevSize",
		"curSize",
		"autoScrollPlugin",
		"id",
		"install",
		"scope",
		"actions",
		"phaselessTypes",
		"autoscroll",
		"perAction",
		"listeners",
		"[object Object]",
		"interactions:stop",
		"arg"
	],
	"mappings": "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",
	"sourcesContent": [
		"import * as domUtils from '@interactjs/utils/domUtils'\nimport * as is from '@interactjs/utils/is'\nimport raf from '@interactjs/utils/raf'\nimport { getStringOptionResult } from '@interactjs/utils/rect'\nimport { getWindow } from '@interactjs/utils/window'\n\ntype Scope = import ('@interactjs/core/scope').Scope\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    autoScroll: typeof autoScroll\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    autoScroll?: typeof autoScroll\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface PerActionDefaults {\n    autoScroll?: AutoScrollOptions\n  }\n}\n\nexport interface AutoScrollOptions {\n  container?: Window | HTMLElement\n  margin?: number\n  distance?: number\n  interval?: number\n  speed?: number\n  enabled?: boolean\n}\n\nfunction install (scope: Scope) {\n  const {\n    defaults,\n    actions,\n  } = scope\n\n  scope.autoScroll = autoScroll\n  autoScroll.now = () => scope.now()\n\n  actions.phaselessTypes.autoscroll = true\n  defaults.perAction.autoScroll = autoScroll.defaults\n}\n\nconst autoScroll = {\n  defaults: {\n    enabled  : false,\n    margin   : 60,\n\n    // the item that is scrolled (Window or HTMLElement)\n    container: null as AutoScrollOptions['container'],\n\n    // the scroll speed in pixels per second\n    speed    : 300,\n  } as AutoScrollOptions,\n\n  now: Date.now,\n\n  interaction: null as Interact.Interaction,\n  i: 0, // the handle returned by window.setInterval\n\n  // Direction each pulse is to scroll in\n  x: 0,\n  y: 0,\n\n  isScrolling: false,\n  prevTime: 0,\n  margin: 0,\n  speed: 0,\n\n  start (interaction: Interact.Interaction) {\n    autoScroll.isScrolling = true\n    raf.cancel(autoScroll.i)\n\n    interaction.autoScroll = autoScroll\n    autoScroll.interaction = interaction\n    autoScroll.prevTime = autoScroll.now()\n    autoScroll.i = raf.request(autoScroll.scroll)\n  },\n\n  stop () {\n    autoScroll.isScrolling = false\n    if (autoScroll.interaction) {\n      autoScroll.interaction.autoScroll = null\n    }\n    raf.cancel(autoScroll.i)\n  },\n\n  // scroll the window by the values in scroll.x/y\n  scroll () {\n    const { interaction } = autoScroll\n    const { interactable, element } = interaction\n    const actionName = interaction.prepared.name\n    const options = interactable.options[actionName].autoScroll\n    const container = getContainer(options.container, interactable, element)\n    const now = autoScroll.now()\n    // change in time in seconds\n    const dt = (now - autoScroll.prevTime) / 1000\n    // displacement\n    const s = options.speed * dt\n\n    if (s >= 1) {\n      const scrollBy = {\n        x: autoScroll.x * s,\n        y: autoScroll.y * s,\n      }\n\n      if (scrollBy.x || scrollBy.y) {\n        const prevScroll = getScroll(container)\n\n        if (is.window(container)) {\n          container.scrollBy(scrollBy.x, scrollBy.y)\n        }\n        else if (container) {\n          container.scrollLeft += scrollBy.x\n          container.scrollTop  += scrollBy.y\n        }\n\n        const curScroll = getScroll(container)\n        const delta = {\n          x: curScroll.x - prevScroll.x,\n          y: curScroll.y - prevScroll.y,\n        }\n\n        if (delta.x || delta.y) {\n          interactable.fire({\n            type: 'autoscroll',\n            target: element,\n            interactable,\n            delta,\n            interaction,\n            container,\n          })\n        }\n      }\n\n      autoScroll.prevTime = now\n    }\n\n    if (autoScroll.isScrolling) {\n      raf.cancel(autoScroll.i)\n      autoScroll.i = raf.request(autoScroll.scroll)\n    }\n  },\n  check (interactable: Interact.Interactable, actionName: Interact.ActionName) {\n    const options = interactable.options\n\n    return options[actionName].autoScroll && options[actionName].autoScroll.enabled\n  },\n  onInteractionMove<T extends Interact.ActionName> ({ interaction, pointer }: { interaction: Interact.Interaction<T>, pointer: Interact.PointerType }) {\n    if (!(interaction.interacting() &&\n          autoScroll.check(interaction.interactable, interaction.prepared.name))) {\n      return\n    }\n\n    if (interaction.simulation) {\n      autoScroll.x = autoScroll.y = 0\n      return\n    }\n\n    let top\n    let right\n    let bottom\n    let left\n\n    const { interactable, element } = interaction\n    const actionName = interaction.prepared.name\n    const options = interactable.options[actionName].autoScroll\n    const container = getContainer(options.container, interactable, element)\n\n    if (is.window(container)) {\n      left   = pointer.clientX < autoScroll.margin\n      top    = pointer.clientY < autoScroll.margin\n      right  = pointer.clientX > container.innerWidth  - autoScroll.margin\n      bottom = pointer.clientY > container.innerHeight - autoScroll.margin\n    }\n    else {\n      const rect = domUtils.getElementClientRect(container)\n\n      left   = pointer.clientX < rect.left   + autoScroll.margin\n      top    = pointer.clientY < rect.top    + autoScroll.margin\n      right  = pointer.clientX > rect.right  - autoScroll.margin\n      bottom = pointer.clientY > rect.bottom - autoScroll.margin\n    }\n\n    autoScroll.x = (right ? 1 : left ? -1 : 0)\n    autoScroll.y = (bottom ? 1 :  top ? -1 : 0)\n\n    if (!autoScroll.isScrolling) {\n      // set the autoScroll properties to those of the target\n      autoScroll.margin = options.margin\n      autoScroll.speed  = options.speed\n\n      autoScroll.start(interaction)\n    }\n  },\n}\n\nexport function getContainer (value: any, interactable: Interact.Interactable, element: Interact.Element) {\n  return (is.string(value) ? getStringOptionResult(value, interactable, element) : value) || getWindow(element)\n}\n\nexport function getScroll (container: any) {\n  if (is.window(container)) { container = window.document.body }\n\n  return { x: container.scrollLeft, y: container.scrollTop }\n}\n\nexport function getScrollSize (container: any) {\n  if (is.window(container)) { container = window.document.body }\n\n  return { x: container.scrollWidth, y: container.scrollHeight }\n}\n\nexport function getScrollSizeDelta<T extends Interact.ActionName> ({ interaction, element }: {\n  interaction: Partial<Interact.Interaction<T>>\n  element: Interact.Element\n}, func: any) {\n  const scrollOptions = interaction && interaction.interactable.options[interaction.prepared.name].autoScroll\n\n  if (!scrollOptions || !scrollOptions.enabled) {\n    func()\n    return { x: 0, y: 0 }\n  }\n\n  const scrollContainer = getContainer(\n    scrollOptions.container,\n    interaction.interactable,\n    element,\n  )\n\n  const prevSize = getScroll(scrollContainer)\n  func()\n  const curSize = getScroll(scrollContainer)\n\n  return {\n    x: curSize.x - prevSize.x,\n    y: curSize.y - prevSize.y,\n  }\n}\n\nconst autoScrollPlugin: Interact.Plugin = {\n  id: 'auto-scroll',\n  install,\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.autoScroll = null\n    },\n\n    'interactions:destroy': ({ interaction }) => {\n      interaction.autoScroll = null\n      autoScroll.stop()\n      if (autoScroll.interaction) {\n        autoScroll.interaction = null\n      }\n    },\n\n    'interactions:stop': autoScroll.stop,\n\n    'interactions:action-move': (arg: any) => autoScroll.onInteractionMove(arg),\n  },\n}\n\nexport default autoScrollPlugin\n"
	]
}